<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>×©×¨×˜×•×˜ ×—×›× - ×¦×™×œ×•× â†’ ×–×™×”×•×™ ×¦×œ×¢×•×ª â†’ ×©×¨×˜×•×˜ ××“×•×™×§</title>

<script async src="https://docs.opencv.org/4.7.0/opencv.js" onload="__onCvScriptLoaded()"></script>

<style>
  :root{--bg:#f4f6f9;--card:#fff;--text:#111827;--muted:#6b7280;--primary:#2563eb;--danger:#dc2626;--line:#e5e7eb;}
  *{box-sizing:border-box}
  body{margin:0;padding:16px;font-family:system-ui,Arial;background:var(--bg);color:var(--text)}
  .wrap{max-width:980px;margin:0 auto}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;margin-bottom:14px;box-shadow:0 10px 25px rgba(0,0,0,.08)}
  h2{margin:0 0 10px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{
    width:100%; padding:14px 16px; border:0; border-radius:12px;
    background:var(--primary); color:#fff; font-size:18px; cursor:pointer;
  }
  .btn:disabled{opacity:.55; cursor:not-allowed}
  .btn.secondary{background:#111827}
  .btn.danger{background:var(--danger)}
  .note{color:var(--muted);font-size:14px;margin-top:8px;line-height:1.45}
  video,canvas{width:100%;border-radius:12px;border:1px solid var(--line);background:#fff}
  .hidden{display:none}
  input{
    width:100%; padding:12px; border:1px solid var(--line); border-radius:12px;
    font-size:16px; outline:none; margin-bottom:10px;
  }
  input:focus{border-color:var(--primary); box-shadow:0 0 0 3px rgba(37,99,235,.12)}
  .status{
    padding:10px 12px; border-radius:12px; border:1px solid var(--line);
    background:#fff; color:#111827; font-size:14px;
  }
  .status.good{border-color:rgba(34,197,94,.35)}
  .status.bad{border-color:rgba(220,38,38,.35)}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  
  /* ××™×›×œ ×œ×§× ×‘×¡ ×”×××¤×©×¨ ×–×•× */
  #canvas-container {
    overflow: hidden;
    touch-action: none; /* ××‘×˜×œ ×’×œ×™×œ×” ×›×‘×¨×™×¨×ª ××—×“×œ ×›×“×™ ×œ××¤×©×¨ pinch-to-zoom */
    border-radius: 12px;
    background: #fff;
    border: 1px solid var(--line);
    position: relative;
    width: 100%;
  }
  #result {
    transform-origin: center center;
    transition: transform 0.1s ease-out;
    display: block;
  }
</style>
</head>

<body>
<div class="wrap">

  <div class="card">
    <h2>1ï¸âƒ£ ×¦×™×œ×•× ×©×¨×˜×•×˜ (××¦×œ××” ××—×•×¨×™×ª)</h2>
    <div id="statusBox" class="status">×˜×•×¢×Ÿâ€¦</div>
    <div class="note">×”×›×¤×ª×•×¨ â€œ×¦×œ×â€ ×™×•×¤×¢×œ ×¨×§ ××—×¨×™ ×©Ö¾<b>×”××¦×œ××” ××•×›× ×”</b> ×•×’× <b>OpenCV ××•×›×Ÿ</b>.</div>

    <div style="margin-top:12px">
      <video id="video" autoplay playsinline></video>
      <canvas id="photo" class="hidden"></canvas>
    </div>

    <div class="row" style="margin-top:12px">
      <button id="btnShot" class="btn" type="button" disabled>ğŸ“¸ ×¦×œ×</button>
      <button id="btnRestart" class="btn secondary" type="button">ğŸ”„ ××ª×—×œ ××¦×œ××”</button>
    </div>
  </div>

  <div class="card hidden" id="previewCard">
    <h2>2ï¸âƒ£ ×§×•×•×™× ××–×•×”×™× + ××¡×¤×•×¨ ×¦×œ×¢×•×ª</h2>
    <canvas id="overlay"></canvas>
    <div id="overlayInfo" class="note"></div>
  </div>

  <div class="card hidden" id="inputsCard">
    <h2>3ï¸âƒ£ ×”×–×Ÿ ××™×“×•×ª (×‘×¡×´×) ×œ×¤×™ ×”××¡×¤×¨×™× ×¢×œ ×”×©×¨×˜×•×˜</h2>
    <div id="inputs"></div>
    <button id="btnBuild" class="btn" type="button">ğŸ“ ×‘× ×” ×©×¨×˜×•×˜ ×œ×¤×™ ×”××™×“×•×ª</button>
    <div class="note">
      ×”×›×œ ×‘×¡×´×. ×”×¤×¨×•×¤×•×¨×¦×™×•×ª ×‘×©×¨×˜×•×˜ ×™×”×™×• ×¨×§ ×œ×¤×™ ×”××¡×¤×¨×™×.  
      ×× ×ª×”×™×” ×‘×¢×™×™×ª â€œ×¡×’×™×¨×”â€ â€“ ×ª×§×‘×œ ×”×•×“×¢×” ××“×•×™×§×ª ×‘×›××” ×¡×´× ×–×” ×‘×•×¨×— ××•×¤×§×™/×× ×›×™.
    </div>
  </div>

  <div class="card hidden" id="resultCard">
    <h2>4ï¸âƒ£ ×©×¨×˜×•×˜ ×¡×•×¤×™</h2>
    <div id="canvas-container">
      <canvas id="result"></canvas>
    </div>
    <div class="note">× ×™×ª×Ÿ ×œ×”×’×“×™×œ/×œ×”×§×˜×™×Ÿ ××ª ×”×©×¨×˜×•×˜ ×‘×¢×–×¨×ª ×©×ª×™ ××¦×‘×¢×•×ª.</div>
    <div id="report" class="note"></div>
  </div>

</div>

<script>
  const video = document.getElementById("video");
  const photo = document.getElementById("photo");
  const overlay = document.getElementById("overlay");
  const resultCanvas = document.getElementById("result");
  const resultContainer = document.getElementById("canvas-container");

  const previewCard = document.getElementById("previewCard");
  const inputsCard = document.getElementById("inputsCard");
  const resultCard = document.getElementById("resultCard");

  const statusBox = document.getElementById("statusBox");
  const btnShot = document.getElementById("btnShot");
  const btnRestart = document.getElementById("btnRestart");
  const btnBuild = document.getElementById("btnBuild");

  let stream = null;
  let videoReady = false;
  let cvReady = false;

  let polyPts = [];     
  let edgeDirs = [];    
  let edgeCount = 0;

  // ××©×ª× ×™ ×–×•×
  let currentScale = 1;
  let initialDist = 0;

  function setStatus(msg, type){
    statusBox.textContent = msg;
    statusBox.classList.remove("good","bad");
    if(type) statusBox.classList.add(type);
  }
  function updateShotEnabled(){ btnShot.disabled = !(videoReady && cvReady); }

  function __onCvScriptLoaded(){
    const wait = setInterval(() => {
      if (window.cv && cv.Mat) {
        try{
          const t = new cv.Mat();
          t.delete();
          cvReady = true;
          setStatus("OpenCV ××•×›×Ÿ âœ…", "good");
          updateShotEnabled();
          clearInterval(wait);
        }catch(e){}
      }
    }, 80);
  }

  async function startCamera(){
    try{
      videoReady = false;
      updateShotEnabled();
      setStatus("×¤×•×ª×— ××¦×œ××” ××—×•×¨×™×ªâ€¦", null);

      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }

      try{
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { exact: "environment" }, width:{ideal:1920}, height:{ideal:1080} },
          audio:false
        });
      } catch(e1){
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio:false
        });
      }

      video.srcObject = stream;
      await new Promise(res => video.onloadedmetadata = () => res());
      await video.play();

      videoReady = true;
      setStatus("××¦×œ××” ××•×›× ×” âœ… (××—×•×¨×™×ª)", "good");
      updateShotEnabled();
    } catch(err){
      setStatus("×©×’×™××” ×‘×¤×ª×™×—×ª ××¦×œ××”: " + (err?.message || err), "bad");
      btnShot.disabled = true;
    }
  }

  function captureToCanvas(){
    const vw = video.videoWidth, vh = video.videoHeight;
    if(!vw || !vh) throw new Error("×”×•×•×™×“××• ×¢×“×™×™×Ÿ ×œ× ××•×›×Ÿ (× ×¡×” ×©×•×‘ ×‘×¢×•×“ ×©× ×™×™×”).");

    photo.width = vw; photo.height = vh;
    const ctx = photo.getContext("2d", { willReadFrequently:true });
    ctx.drawImage(video, 0, 0, vw, vh);
  }

  function centroid(pts){
    let sx=0, sy=0;
    for(const p of pts){ sx+=p.x; sy+=p.y; }
    return {x:sx/pts.length, y:sy/pts.length};
  }
  function sortAroundCenter(pts){
    const c = centroid(pts);
    return [...pts].sort((a,b) => Math.atan2(a.y-c.y, a.x-c.x) - Math.atan2(b.y-c.y, b.x-c.x));
  }
  function snapDir(dx, dy){
    if (Math.abs(dx) >= Math.abs(dy)) return {dx: Math.sign(dx) || 1, dy: 0};
    return {dx: 0, dy: Math.sign(dy) || 1};
  }

  function detectAndNumberEdges(){
    if(!cvReady) throw new Error("OpenCV ×œ× ××•×›×Ÿ.");

    let src = cv.imread(photo);
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let edges = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
    cv.Canny(blur, edges, 60, 180);

    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
    cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    if(contours.size() === 0) cleanupAndThrow("×œ× × ××¦××• ×§×•×•×™×/×§×•× ×˜×•×¨×™×. ×ª×¦×œ× ×¢× ×™×•×ª×¨ × ×™×’×•×“×™×•×ª.");

    let biggest = null, maxArea = 0;
    for(let i=0;i<contours.size();i++){
      const cnt = contours.get(i);
      const area = cv.contourArea(cnt);
      if(area > maxArea){ maxArea = area; biggest = cnt; }
    }
    if(!biggest || maxArea < 5000) cleanupAndThrow("×”×¦×•×¨×” ×§×˜× ×” ××“×™ ××• ×œ× ×‘×¨×•×¨×”. ×ª×§×¨×‘ ××¦×œ××”/×ª×¢×‘×” ×§×•×•×™×.");

    const peri = cv.arcLength(biggest, true);
    const epsCandidates = [0.015, 0.02, 0.03, 0.04].map(k => k*peri);

    let approx = new cv.Mat();
    let pts = null;

    for(const eps of epsCandidates){
      cv.approxPolyDP(biggest, approx, eps, true);
      if(approx.rows >= 3 && approx.rows <= 20){
        pts = [];
        for(let i=0;i<approx.rows;i++){
          pts.push({ x: approx.intPtr(i,0)[0], y: approx.intPtr(i,0)[1] });
        }
        break;
      }
    }

    if(!pts || pts.length < 3) cleanupAndThrow("×œ× ×”×¦×œ×—×ª×™ ×œ×¤×¨×© ×¤×™× ×•×ª ×‘×¦×•×¨×” ×™×¦×™×‘×”. × ×¡×” ×¦×™×œ×•× ×‘×¨×•×¨ ×™×•×ª×¨.");

    polyPts = sortAroundCenter(pts);
    edgeCount = polyPts.length;

    edgeDirs = [];
    for(let i=0;i<edgeCount;i++){
      const a = polyPts[i];
      const b = polyPts[(i+1)%edgeCount];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      edgeDirs.push(snapDir(dx, dy));
    }

    const W = photo.width, H = photo.height;
    overlay.width = W; overlay.height = H;
    const octx = overlay.getContext("2d");
    octx.drawImage(photo, 0, 0);

    octx.lineWidth = 6;
    octx.strokeStyle = "rgba(37,99,235,0.85)";
    octx.beginPath();
    octx.moveTo(polyPts[0].x, polyPts[0].y);
    for(let i=1;i<edgeCount;i++) octx.lineTo(polyPts[i].x, polyPts[i].y);
    octx.closePath();
    octx.stroke();

    octx.fillStyle = "#ffffff";
    octx.strokeStyle = "rgba(0,0,0,0.55)";
    octx.lineWidth = 4;
    octx.font = "bold 44px system-ui";
    octx.textAlign = "center";
    octx.textBaseline = "middle";

    for(let i=0;i<edgeCount;i++){
      const p1 = polyPts[i];
      const p2 = polyPts[(i+1)%edgeCount];
      const mx = (p1.x+p2.x)/2;
      const my = (p1.y+p2.y)/2;
      octx.strokeText(String(i+1), mx, my);
      octx.fillText(String(i+1), mx, my);
    }

    previewCard.classList.remove("hidden");
    document.getElementById("overlayInfo").textContent =
      `×–×•×”×• ${edgeCount} ×¦×œ×¢×•×ª. ×”××¡×¤×¨×™× ×¢×œ ×”×ª××•× ×” ×”× ×”×¡×“×¨ ×”× ×›×•×Ÿ ×œ×”×–× ×ª ×”××™×“×•×ª.`;

    buildInputs(edgeCount);
    cleanup();

    function cleanup(){
      src.delete(); gray.delete(); blur.delete(); edges.delete();
      kernel.delete(); contours.delete(); hierarchy.delete(); approx.delete();
    }
    function cleanupAndThrow(msg){
      cleanup();
      throw new Error(msg);
    }
  }

  function buildInputs(n){
    const box = document.getElementById("inputs");
    box.innerHTML = "";
    for(let i=0;i<n;i++){
      const input = document.createElement("input");
      input.type="number";
      input.inputMode="numeric";
      input.step="1";
      input.min="1";
      input.placeholder = `×¦×œ×¢ ${i+1} (×‘×¡×´×)`;
      box.appendChild(input);
    }
    inputsCard.classList.remove("hidden");
  }

  function buildFinal(){
    const values = [...document.querySelectorAll("#inputs input")].map(i=>Number(i.value));
    if(values.length !== edgeCount) return alert("××¡×¤×¨ ××™×“×•×ª ×œ× ×ª×•××.");
    if(values.some(v => !Number.isFinite(v) || v<=0)) return alert("×ª×›× ×™×¡ ××™×“×•×ª ×ª×§×™× ×•×ª ×‘×¡×´× ×œ×›×œ ×”×¦×œ×¢×•×ª.");

    const pts = [{x:0,y:0}];
    let x=0,y=0;
    for(let i=0;i<edgeCount;i++){
      x += edgeDirs[i].dx * values[i];
      y += edgeDirs[i].dy * values[i];
      pts.push({x,y});
    }

    // ×—×™×©×•×‘ ×©×˜×— (× ×•×¡×—×ª ×”×©×¨×•×š) ×‘-×¡×"×¨ ×•××– ×”××¨×” ×œ×"×¨
    let areaCm2 = 0;
    for (let i = 0; i < edgeCount; i++) {
        areaCm2 += (pts[i].x * pts[i+1].y) - (pts[i+1].x * pts[i].y);
    }
    areaCm2 = Math.abs(areaCm2) / 2;
    const areaM2 = areaCm2 / 10000; // 10,000 ×¡×"×¨ = 1 ×"×¨

    const end = pts[pts.length-1];
    const closureDx = end.x;
    const closureDy = end.y;

    const W=900, H=520;
    resultCanvas.width=W; resultCanvas.height=H;
    const ctx = resultCanvas.getContext("2d");
    ctx.clearRect(0,0,W,H);

    const xs = pts.map(p=>p.x), ys=pts.map(p=>p.y);
    const minX=Math.min(...xs), maxX=Math.max(...xs);
    const minY=Math.min(...ys), maxY=Math.max(...ys);
    const spanX = (maxX-minX) || 1;
    const spanY = (maxY-minY) || 1;

    const pad=60;
    const scaleFactor = Math.min((W-2*pad)/spanX, (H-2*pad)/spanY);

    function tx(px){ return pad + (px - minX)*scaleFactor; }
    function ty(py){ return pad + (py - minY)*scaleFactor; }

    ctx.lineWidth=3;
    ctx.strokeStyle="#2563eb";
    ctx.fillStyle="rgba(37,99,235,0.07)";

    ctx.beginPath();
    ctx.moveTo(tx(pts[0].x), ty(pts[0].y));
    for(let i=1;i<pts.length;i++) ctx.lineTo(tx(pts[i].x), ty(pts[i].y));
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle="#111827";
    ctx.font="14px system-ui";
    ctx.textAlign="center";
    ctx.textBaseline="bottom";

    for(let i=0;i<edgeCount;i++){
      const p1=pts[i], p2=pts[i+1];
      const mx=(p1.x+p2.x)/2, my=(p1.y+p2.y)/2;
      ctx.fillText(values[i] + " ×¡×´×", tx(mx), ty(my) - 6);
    }

    const per = values.reduce((a,b)=>a+b,0);
    let msg = `×”×™×§×£: ${per} ×¡×´× | ×©×˜×—: ${areaM2.toFixed(2)} ××´×¨.`;
    
    if(Math.abs(closureDx) > 0.5 || Math.abs(closureDy) > 0.5){
      msg += ` <br>âš ï¸ ×”×¦×•×¨×” ×œ× × ×¡×’×¨×ª: ×¡×˜×™×™×” X: ${closureDx.toFixed(1)}, Y: ${closureDy.toFixed(1)} ×¡×´×.`;
    } else {
      msg += "<br> âœ… ×”×¦×•×¨×” × ×¡×’×¨×ª ×ª×§×™×Ÿ.";
    }

    document.getElementById("report").innerHTML = msg;
    resultCard.classList.remove("hidden");
    
    // ××™×¤×•×¡ ×–×•× ×‘×›×œ ×‘× ×™×™×” ××—×“×©
    currentScale = 1;
    resultCanvas.style.transform = `scale(1)`;
  }

  // --- ×œ×•×’×™×§×ª ×¦×‘×™×˜×” (Pinch-to-Zoom) ---
  resultContainer.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      initialDist = Math.hypot(
        e.touches[0].pageX - e.touches[1].pageX,
        e.touches[0].pageY - e.touches[1].pageY
      );
    }
  }, {passive: false});

  resultContainer.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const currentDist = Math.hypot(
        e.touches[0].pageX - e.touches[1].pageX,
        e.touches[0].pageY - e.touches[1].pageY
      );
      
      const zoomFactor = currentDist / initialDist;
      let newScale = currentScale * zoomFactor;
      
      // ×”×’×‘×œ×” ×œ×–×•× ×¡×‘×™×¨
      newScale = Math.min(Math.max(0.5, newScale), 5);
      
      resultCanvas.style.transform = `scale(${newScale})`;
      currentScale = newScale;
      initialDist = currentDist; // ×¢×“×›×•×Ÿ ×œ××¨×—×§ ×”×‘×
    }
  }, {passive: false});

  btnShot.addEventListener("click", () => {
    try{
      setStatus("××¦×œ× ×•××–×”×” ×¦×œ×¢×•×ªâ€¦", null);
      captureToCanvas();
      detectAndNumberEdges();
      setStatus("×–×™×”×•×™ ×”×¦×œ×™×— âœ…", "good");
    } catch(e){
      setStatus("×©×’×™××”: " + (e?.message || e), "bad");
    }
  });

  btnRestart.addEventListener("click", () => {
    previewCard.classList.add("hidden");
    inputsCard.classList.add("hidden");
    resultCard.classList.add("hidden");
    document.getElementById("inputs").innerHTML = "";
    polyPts=[]; edgeDirs=[]; edgeCount=0;
    startCamera();
  });

  btnBuild.addEventListener("click", () => {
    try{ buildFinal(); } catch(e){ alert("×©×’×™××”: " + (e?.message || e)); }
  });

  setStatus("×××ª×—×œâ€¦", null);
  startCamera();
</script>

</body>
</html>
