<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>×¡×•×¨×§ ××—×™×¨×™×</title>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #101827;
      color: #f9fafb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Heebo", Arial, sans-serif;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 12px;
    }

    .wrapper {
      width: 100%;
      max-width: 480px;
      margin-top: 8px;
    }

    h1 {
      font-size: 20px;
      text-align: center;
      margin-bottom: 10px;
    }

    /* ğŸ”¹ ×—×œ×•×Ÿ ×ª×¦×•×’×” ××œ×‘× ×™ â€“ ×™×—×¡ 2:1 (4:2) */
    .camera-box {
      position: relative;
      width: 100%;
      max-width: 420px;
      aspect-ratio: 2 / 1;
      background: #020617;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.4);
      margin: 0 auto;
    }

    #preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .info {
      font-size: 13px;
      color: #cbd5f5;
      margin-top: 6px;
      text-align: center;
    }

    #status {
      margin-top: 6px;
      font-size: 13px;
      text-align: center;
      min-height: 18px;
      color: #e5e7eb;
    }

    .btn-row {
      margin-top: 10px;
      display: flex;
      justify-content: center;
    }

    button.main-btn {
      padding: 10px 18px;
      font-size: 16px;
      border-radius: 999px;
      border: none;
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 8px 18px rgba(34, 197, 94, 0.35);
      cursor: pointer;
      min-width: 180px;
    }

    button.main-btn:active {
      transform: translateY(1px);
      box-shadow: 0 4px 10px rgba(34, 197, 94, 0.4);
    }

    .list-box {
      margin-top: 14px;
      background: #020617;
      border-radius: 14px;
      padding: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .list-header {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      margin-bottom: 6px;
      color: #e5e7eb;
    }

    ul {
      list-style: none;
      max-height: 220px;
      overflow-y: auto;
    }

    li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      padding: 4px 0;
      border-bottom: 1px solid rgba(51, 65, 85, 0.6);
      font-size: 14px;
    }

    li:last-child {
      border-bottom: none;
    }

    .item-label {
      flex: 1;
    }

    .item-price {
      min-width: 70px;
      text-align: left;
    }

    /* ğŸ”´ ×›×¤×ª×•×¨ ××—×™×§×” ×××© ×§×˜×Ÿ */
    .delete-btn {
      border: none;
      border-radius: 999px;
      padding: 1px 5px;
      font-size: 9px;
      background: #ef4444;
      color: #fef2f2;
      cursor: pointer;
      flex-shrink: 0;
      line-height: 1.1;
    }

    .delete-btn:active {
      transform: translateY(1px);
    }

    .total-row {
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px solid rgba(148, 163, 184, 0.7);
      display: flex;
      justify-content: space-between;
      font-weight: 700;
      font-size: 16px;
    }

    .total-label {
      color: #e5e7eb;
    }

    .total-value {
      color: #22c55e;
    }

    #captureCanvas {
      display: none;
    }

    /* ğŸ”¹ ×§×•×¤×¡×ª ××™×©×•×¨ ××—×™×¨ */
    .confirm-box {
      margin-top: 8px;
      background: #020617;
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      font-size: 13px;
      display: none;
    }

    .confirm-top {
      margin-bottom: 6px;
    }

    .confirm-price {
      font-weight: 700;
      color: #22c55e;
    }

    .confirm-buttons {
      display: flex;
      gap: 6px;
      justify-content: center;
    }

    .mini-btn {
      border-radius: 999px;
      border: none;
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .mini-btn.yes {
      background: #22c55e;
      color: #022c22;
    }

    .mini-btn.edit {
      background: #4b5563;
      color: #e5e7eb;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>×¡×•×¨×§ ××—×™×¨×™× ×¤×©×•×˜</h1>

    <div class="camera-box">
      <img id="preview" alt="×ª×¦×•×’×ª ×¦×™×œ×•×">
    </div>

    <div class="info">
      ×œ×—×¥ ×¢×œ "×¦×œ× ××“×‘×§×”", ×›×•×•×Ÿ ××ª ×”×ª×•×•×™×ª ×•×¦×•×¨ ×¦×™×œ×•× ×—×“ ×©×œ ×”××—×™×¨.
    </div>
    <div id="status"></div>

    <div class="btn-row">
      <button id="captureBtn" class="main-btn">×¦×œ× ××“×‘×§×”</button>
    </div>

    <!-- ×§×•×¤×¡×ª ××™×©×•×¨ ××—×™×¨ -->
    <div id="confirmBox" class="confirm-box">
      <div class="confirm-top">
        ×–×•×”×” ××—×™×¨: <span id="confirmPrice" class="confirm-price"></span> â‚ª.<br>
        ×”×× ×–×” ×”××—×™×¨ ×”× ×›×•×Ÿ?
      </div>
      <div class="confirm-buttons">
        <button id="confirmYes" class="mini-btn yes">×›×Ÿ, ×”×•×¡×£ ×œ×¡×œ</button>
        <button id="confirmEdit" class="mini-btn edit">×œ×, ×× ×™ ××ª×§×Ÿ</button>
      </div>
    </div>

    <div class="list-box">
      <div class="list-header">
        <span>××•×¦×¨</span>
        <span>××—×™×¨ (â‚ª)</span>
      </div>
      <ul id="itemsList"></ul>
      <div class="total-row">
        <span class="total-label">×¡×”×´×›:</span>
        <span class="total-value" id="totalPrice">0.00</span>
      </div>
    </div>
  </div>

  <!-- ×§× ×‘×¡ × ×¡×ª×¨ ×œ-OCR -->
  <canvas id="captureCanvas"></canvas>

  <!-- ××™× ×¤×•×˜ × ×¡×ª×¨ ×œ×¦×™×œ×•× ×¡×˜×™×œ×¡ ××”××¦×œ××” ×”××—×•×¨×™×ª -->
  <input type="file" id="photoInput" accept="image/*" capture="environment" style="display:none;">

  <script src="https://unpkg.com/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
  <script>
    const captureBtn = document.getElementById('captureBtn');
    const photoInput = document.getElementById('photoInput');
    const preview = document.getElementById('preview');
    const statusEl = document.getElementById('status');
    const captureCanvas = document.getElementById('captureCanvas');
    const itemsList = document.getElementById('itemsList');
    const totalPriceEl = document.getElementById('totalPrice');

    const confirmBox = document.getElementById('confirmBox');
    const confirmPriceEl = document.getElementById('confirmPrice');
    const confirmYesBtn = document.getElementById('confirmYes');
    const confirmEditBtn = document.getElementById('confirmEdit');

    const prices = [];
    let pendingPrice = null;

    // ×œ×—×™×¦×” ×¢×œ "×¦×œ× ××“×‘×§×”" -> ×¤×•×ª×— ××¦×œ××” (×¡×˜×™×œ×¡)
    captureBtn.addEventListener('click', () => {
      photoInput.value = '';
      photoInput.click();
    });

    // ×§×‘×œ×ª ×ª××•× ×” ××”××¦×œ××”/×’×œ×¨×™×”
    photoInput.addEventListener('change', () => {
      const file = photoInput.files && photoInput.files[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = async () => {
        preview.src = url;
        try {
          await processImageForPrice(img);
        } finally {
          // × ×©××™×¨ ××ª ×”-URL ×œ×ª×¦×•×’×”, ×œ× ××‘×˜×œ ×›×¨×’×¢
          // URL.revokeObjectURL(url);
        }
      };
      img.onerror = () => {
        statusEl.textContent = '×œ× × ×™×ª×Ÿ ×œ×˜×¢×•×Ÿ ××ª ×”×ª××•× ×”.';
      };
      img.src = url;
    });

    // ××œ×’×•×¨×™×ª× × ×™×§×•×™ ×•×“×¨×•×’ ××—×™×¨×™× â€“ ×‘×œ×™ ×¡×™× ×•×Ÿ ×˜×•×•×— ×§×©×™×—
    function extractPriceFromText(text) {
      if (!text) return null;

      let cleaned = text.replace(/[^0-9.,]/g, ' ');
      const matches = cleaned.match(/\d{1,5}(?:[.,]\d{1,2})?/g);
      if (!matches) return null;

      const candidates = [];

      for (const raw of matches) {
        if (!raw) continue;

        let norm = raw.replace(/,/g, '.');
        const partsDot = norm.split('.');
        if (partsDot.length > 2) {
          norm = partsDot[0] + '.' + partsDot[1];
        }

        const value = parseFloat(norm);
        if (isNaN(value)) continue;
        if (value <= 0) continue;

        candidates.push({ raw: norm, value });
      }

      if (!candidates.length) return null;

      function scoreCandidate(c) {
        const raw = c.raw;
        const value = c.value;

        const parts = raw.split('.');
        const intPart = parts[0] || '';
        const fracPart = parts[1] || '';

        let score = 0;

        score += intPart.length * 2;

        if (fracPart.length === 2) score += 4;
        else if (fracPart.length === 1) score += 2;

        const cents = Math.round((value - Math.floor(value)) * 100);
        const typicalCents = [0, 5, 9, 10, 20, 50, 90, 95, 99];
        if (typicalCents.includes(cents)) score += 3;

        if (value >= 0.5 && value <= 500) score += 3;
        else if (value > 500 && value <= 5000) score += 1;

        if (intPart.length >= 2 && intPart.length <= 4) score += 2;

        return score;
      }

      let best = candidates[0];
      let bestScore = scoreCandidate(best);

      for (let i = 1; i < candidates.length; i++) {
        const s = scoreCandidate(candidates[i]);
        if (s > bestScore) {
          bestScore = s;
          best = candidates[i];
        }
      }

      return best.value;
    }

    // ×©×—×•×¨-×œ×‘×Ÿ + ×§×•× ×˜×¨×¡×˜
    function applyGrayscaleAndContrast(ctx, width, height) {
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      const contrast = 1.4;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        let gray = 0.299 * r + 0.587 * g + 0.114 * b;

        gray = (gray - 128) * contrast + 128;
        if (gray < 0) gray = 0;
        if (gray > 255) gray = 255;

        data[i] = data[i + 1] = data[i + 2] = gray;
      }

      ctx.putImageData(imageData, 0, 0);
    }

    // ×¢×™×‘×•×“ ×ª××•× ×” â†’ OCR â†’ ×”×¦×’×ª ××™×©×•×¨
    async function processImageForPrice(img) {
      statusEl.textContent = '××–×”×” ××—×™×¨ ××”×ª××•× ×”...';

      // × ×§×˜×™×Ÿ ×× ×¦×¨×™×š, ×›×“×™ ×œ× ×œ×”×¢××™×¡
      const maxWidth = 1000;
      const scale = img.naturalWidth > maxWidth ? maxWidth / img.naturalWidth : 1;
      const fullW = img.naturalWidth * scale;
      const fullH = img.naturalHeight * scale;

      // ××‘×¦×¢×™× crop ××œ×‘× ×™ ××¨×›×–×™ ×‘×™×—×¡ 2:1
      let roiW = fullW * 0.8;
      let roiH = roiW / 2; // ×™×—×¡ 2:1

      if (roiH > fullH * 0.8) {
        roiH = fullH * 0.8;
        roiW = roiH * 2;
      }

      const sx = (fullW - roiW) / 2;
      const sy = (fullH - roiH) / 2;

      const targetW = Math.floor(roiW * 2);
      const targetH = Math.floor(roiH * 2);

      captureCanvas.width = targetW;
      captureCanvas.height = targetH;
      const ctx = captureCanvas.getContext('2d');

      ctx.drawImage(
        img,
        sx / scale,
        sy / scale,
        roiW / scale,
        roiH / scale,
        0,
        0,
        targetW,
        targetH
      );

      applyGrayscaleAndContrast(ctx, targetW, targetH);

      try {
        const result = await Tesseract.recognize(
          captureCanvas,
          'eng',
          {
            logger: () => {},
            tessedit_char_whitelist: '0123456789.,',
            user_defined_dpi: '300'
          }
        );

        const rawText = result.data.text;
        const price = extractPriceFromText(rawText);

        if (price == null) {
          statusEl.textContent =
            '×œ× ×”×¦×œ×—×ª×™ ×œ××¦×•× ××—×™×¨ ×‘×¨×•×¨. × ×¡×” ×œ×¦×œ× ×§×¨×•×‘ ×™×•×ª×¨ ×•×œ×•×•×“× ×©×”×ª×•×•×™×ª ×™×©×¨×”.';
          pendingPrice = null;
          confirmBox.style.display = 'none';
          return;
        }

        const rounded = Math.round(price * 100) / 100;
        pendingPrice = rounded;

        confirmPriceEl.textContent = rounded.toFixed(2);
        confirmBox.style.display = 'block';
        statusEl.textContent = '';
      } catch (err) {
        statusEl.textContent = '×©×’×™××” ×‘×–×™×”×•×™ ××—×™×¨: ' + err.message;
        pendingPrice = null;
        confirmBox.style.display = 'none';
      }
    }

    function renderList() {
      itemsList.innerHTML = '';
      let total = 0;

      prices.forEach((price, index) => {
        total += price;

        const li = document.createElement('li');

        const labelSpan = document.createElement('span');
        labelSpan.className = 'item-label';
        labelSpan.textContent = '××•×¦×¨ ' + (index + 1);

        const priceSpan = document.createElement('span');
        priceSpan.className = 'item-price';
        priceSpan.textContent = price.toFixed(2);

        const delBtn = document.createElement('button');
        delBtn.className = 'delete-btn';
        delBtn.textContent = '××—×§';
        delBtn.dataset.index = index.toString();

        li.appendChild(labelSpan);
        li.appendChild(priceSpan);
        li.appendChild(delBtn);

        itemsList.appendChild(li);
      });

      totalPriceEl.textContent = total.toFixed(2);
    }

    // ××—×™×§×ª ××•×¦×¨ ×‘×•×“×“
    itemsList.addEventListener('click', (event) => {
      const target = event.target;
      if (target.classList.contains('delete-btn')) {
        const index = parseInt(target.dataset.index, 10);
        if (!isNaN(index)) {
          prices.splice(index, 1);
          renderList();
        }
      }
    });

    // ××™×©×•×¨ "×›×Ÿ, ×”×•×¡×£ ×œ×¡×œ"
    confirmYesBtn.addEventListener('click', () => {
      if (pendingPrice != null) {
        prices.push(pendingPrice);
        renderList();
        statusEl.textContent = '× ×•×¡×£ ××•×¦×¨: ' + pendingPrice.toFixed(2) + ' â‚ª';
      }
      pendingPrice = null;
      confirmBox.style.display = 'none';
    });

    // "×œ×, ×× ×™ ××ª×§×Ÿ" â†’ ××‘×§×© ×××š ××—×™×¨ ×™×“× ×™×ª
    confirmEditBtn.addEventListener('click', () => {
      const current = pendingPrice != null ? pendingPrice.toFixed(2) : '';
      const manualStr = prompt('×”×›× ×¡ ××ª ×”××—×™×¨ ×”× ×›×•×Ÿ (×œ××©×œ 10.90):', current);
      if (manualStr === null) {
        // ×‘×™×˜×•×œ
        return;
      }
      const manual = parseFloat(manualStr.replace(',', '.'));
      if (isNaN(manual) || manual <= 0) {
        alert('××—×™×¨ ×œ× ×—×•×§×™. × ×¡×” ×©×•×‘.');
        return;
      }
      const rounded = Math.round(manual * 100) / 100;
      prices.push(rounded);
      renderList();
      statusEl.textContent = '× ×•×¡×£ ××•×¦×¨ (××¢×•×“×›×Ÿ ×™×“× ×™×ª): ' + rounded.toFixed(2) + ' â‚ª';
      pendingPrice = null;
      confirmBox.style.display = 'none';
    });
  </script>
</body>
</html>
