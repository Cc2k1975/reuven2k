<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>×©×¨×˜×•×˜ ×—×›× - ×”×©×•×•××ª ×›×™×•×•× ×™ ×¨×™×¦×•×£</title>

<script async src="https://docs.opencv.org/4.7.0/opencv.js" onload="__onCvScriptLoaded()"></script>

<style>
  :root{--bg:#f4f6f9;--card:#fff;--text:#111827;--muted:#6b7280;--primary:#2563eb;--danger:#dc2626;--line:#e5e7eb;}
  *{box-sizing:border-box}
  body{margin:0;padding:16px;font-family:system-ui,Arial;background:var(--bg);color:var(--text)}
  .wrap{max-width:980px;margin:0 auto}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;margin-bottom:14px;box-shadow:0 10px 25px rgba(0,0,0,.08)}
  h2{margin:0 0 10px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{
    width:100%; padding:14px 16px; border:0; border-radius:12px;
    background:var(--primary); color:#fff; font-size:18px; cursor:pointer;
  }
  .btn:disabled{opacity:.55; cursor:not-allowed}
  .btn.secondary{background:#111827}
  .btn.danger{background:var(--danger)}
  .note{color:var(--muted);font-size:14px;margin-top:8px;line-height:1.45}
  video,canvas{width:100%;border-radius:12px;border:1px solid var(--line);background:#fff}
  .hidden{display:none}
  input{
    width:100%; padding:12px; border:1px solid var(--line); border-radius:12px;
    font-size:16px; outline:none; margin-bottom:10px;
  }
  input:focus{border-color:var(--primary); box-shadow:0 0 0 3px rgba(37,99,235,.12)}
  .status{
    padding:10px 12px; border-radius:12px; border:1px solid var(--line);
    background:#fff; color:#111827; font-size:14px;
  }
  .status.good{border-color:rgba(34,197,94,.35)}
  .status.bad{border-color:rgba(220,38,38,.35)}
  
  #results-wrapper {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .result-container-single {
    flex: 1;
    min-width: 300px;
    background: #fff;
    position: relative;
    border: 1px solid var(--line);
    border-radius: 12px;
    text-align: center;
    /* touch-action: auto ×××¤×©×¨ ×’×œ×™×œ×” ×¨×’×™×œ×” ×‘×“×£ */
    touch-action: auto; 
    overflow: hidden;
  }
  .result-canvas {
    width: 100%;
    transform-origin: center center;
    transition: transform 0.1s ease-out;
    display: block;
    border: none;
  }
  .tile-label {
    padding: 10px;
    background: #f8fafc;
    border-top: 1px solid var(--line);
    font-weight: bold;
    color: var(--primary);
  }
  .tile-inputs {
    display: flex;
    gap: 10px;
    background: #f0f7ff;
    padding: 12px;
    border-radius: 12px;
    margin-bottom: 15px;
    border: 1px solid #c0d8ff;
  }
</style>
</head>

<body>
<div class="wrap">

  <div class="card">
    <h2>1ï¸âƒ£ ×¦×™×œ×•× ×©×¨×˜×•×˜</h2>
    <div id="statusBox" class="status">×˜×•×¢×Ÿâ€¦</div>
    <div style="margin-top:12px">
      <video id="video" autoplay playsinline></video>
      <canvas id="photo" class="hidden"></canvas>
    </div>
    <div class="row" style="margin-top:12px">
      <button id="btnShot" class="btn" type="button" disabled>ğŸ“¸ ×¦×œ×</button>
      <button id="btnRestart" class="btn secondary" type="button">ğŸ”„ ××ª×—×œ ××¦×œ××”</button>
    </div>
  </div>

  <div class="card hidden" id="previewCard">
    <h2>2ï¸âƒ£ ×§×•×•×™× ××–×•×”×™×</h2>
    <canvas id="overlay"></canvas>
    <div id="overlayInfo" class="note"></div>
  </div>

  <div class="card hidden" id="inputsCard">
    <h2>3ï¸âƒ£ ×”×–×Ÿ ××™×“×•×ª ×©×˜×— ×•×¨×™×¦×•×£ (×¡×´×)</h2>
    
    <div class="tile-inputs">
      <div style="flex:1">
        <label style="font-size: 13px; font-weight: bold; display:block; margin-bottom:4px;">×¨×•×—×‘ ××¨×™×— (×¡"×)</label>
        <input id="tileW" type="number" value="60">
      </div>
      <div style="flex:1">
        <label style="font-size: 13px; font-weight: bold; display:block; margin-bottom:4px;">××•×¨×š ××¨×™×— (×¡"×)</label>
        <input id="tileH" type="number" value="120">
      </div>
    </div>

    <div id="inputs"></div>
    <button id="btnBuild" class="btn" type="button">ğŸ“ ×”×©×•×•×” ×›×™×•×•× ×™ ×¨×™×¦×•×£</button>
  </div>

  <div class="card hidden" id="resultCard">
    <h2>4ï¸âƒ£ ×”×©×•×•××ª ×›×™×•×•× ×™ ×¤×¨×™×¡×”</h2>
    <div id="results-wrapper">
      <div class="result-container-single" id="containerA">
        <div style="padding: 5px; font-size: 12px; font-weight: bold;">××•×¤×¦×™×” ×' (××§×•×¨)</div>
        <canvas id="resultA" class="result-canvas"></canvas>
        <div id="reportA" class="tile-label"></div>
      </div>
      <div class="result-container-single" id="containerB">
        <div style="padding: 5px; font-size: 12px; font-weight: bold;">××•×¤×¦×™×” ×‘' (90Â°)</div>
        <canvas id="resultB" class="result-canvas"></canvas>
        <div id="reportB" class="tile-label"></div>
      </div>
    </div>
    <div id="generalReport" class="note" style="margin-top:15px; text-align:center; font-size:16px; color: #111827;"></div>
  </div>

</div>

<script>
  const video = document.getElementById("video");
  const photo = document.getElementById("photo");
  const overlay = document.getElementById("overlay");
  const previewCard = document.getElementById("previewCard");
  const inputsCard = document.getElementById("inputsCard");
  const resultCard = document.getElementById("resultCard");
  const statusBox = document.getElementById("statusBox");
  const btnShot = document.getElementById("btnShot");
  const btnRestart = document.getElementById("btnRestart");
  const btnBuild = document.getElementById("btnBuild");

  let stream = null;
  let videoReady = false;
  let cvReady = false;
  let polyPts = [];     
  let edgeDirs = [];    
  let edgeCount = 0;
  let currentScale = 1;
  let initialDist = 0;

  function setStatus(msg, type){
    statusBox.textContent = msg;
    statusBox.classList.remove("good","bad");
    if(type) statusBox.classList.add(type);
  }

  function updateShotEnabled(){ btnShot.disabled = !(videoReady && cvReady); }

  function __onCvScriptLoaded(){
    const wait = setInterval(() => {
      if (window.cv && cv.Mat) {
        cvReady = true;
        setStatus("××¢×¨×›×ª ××•×›× ×” âœ…", "good");
        updateShotEnabled();
        clearInterval(wait);
      }
    }, 100);
  }

  async function startCamera(){
    try{
      if (stream) stream.getTracks().forEach(t => t.stop());
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment", width:{ideal:1920}, height:{ideal:1080} }
      });
      video.srcObject = stream;
      await video.play();
      videoReady = true;
      setStatus("××¦×œ××” ××•×›× ×” âœ…", "good");
      updateShotEnabled();
    } catch(err){ setStatus("×©×’×™××” ×‘××¦×œ××”", "bad"); }
  }

  function captureToCanvas(){
    const vw = video.videoWidth, vh = video.videoHeight;
    photo.width = vw; photo.height = vh;
    const ctx = photo.getContext("2d", { willReadFrequently:true });
    ctx.drawImage(video, 0, 0, vw, vh);
  }

  function centroid(pts){
    let sx=0, sy=0;
    pts.forEach(p => { sx+=p.x; sy+=p.y; });
    return {x:sx/pts.length, y:sy/pts.length};
  }

  function sortAroundCenter(pts){
    const c = centroid(pts);
    return [...pts].sort((a,b) => Math.atan2(a.y-c.y, a.x-c.x) - Math.atan2(b.y-c.y, b.x-c.x));
  }

  function snapDir(dx, dy){
    return Math.abs(dx) >= Math.abs(dy) ? {dx: Math.sign(dx) || 1, dy: 0} : {dx: 0, dy: Math.sign(dy) || 1};
  }

  function detectAndNumberEdges(){
    let src = cv.imread(photo);
    let gray = new cv.Mat(), blur = new cv.Mat(), edges = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
    cv.Canny(blur, edges, 60, 180);
    let contours = new cv.MatVector(), hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    
    let biggest = null, maxArea = 0;
    for(let i=0; i<contours.size(); i++){
      let area = cv.contourArea(contours.get(i));
      if(area > maxArea){ maxArea = area; biggest = contours.get(i); }
    }
    if(!biggest) throw new Error("×œ× ×–×•×”×ª×” ×¦×•×¨×”");

    let approx = new cv.Mat();
    cv.approxPolyDP(biggest, approx, 0.02 * cv.arcLength(biggest, true), true);
    
    let pts = [];
    for(let i=0; i<approx.rows; i++){
      pts.push({ x: approx.intPtr(i,0)[0], y: approx.intPtr(i,0)[1] });
    }
    
    polyPts = sortAroundCenter(pts);
    edgeCount = polyPts.length;
    edgeDirs = [];
    for(let i=0; i<edgeCount; i++){
      let a = polyPts[i], b = polyPts[(i+1)%edgeCount];
      edgeDirs.push(snapDir(b.x - a.x, b.y - a.y));
    }

    overlay.width = photo.width; overlay.height = photo.height;
    let octx = overlay.getContext("2d");
    octx.drawImage(photo, 0, 0);
    octx.lineWidth = 6; octx.strokeStyle = "#2563eb";
    octx.beginPath();
    octx.moveTo(polyPts[0].x, polyPts[0].y);
    polyPts.forEach(p => octx.lineTo(p.x, p.y));
    octx.closePath(); octx.stroke();

    buildInputs(edgeCount);
    previewCard.classList.remove("hidden");
    src.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete(); approx.delete();
  }

  function buildInputs(n){
    const box = document.getElementById("inputs");
    box.innerHTML = "";
    for(let i=0; i<n; i++){
      let input = document.createElement("input");
      input.type="number"; input.placeholder = `×¦×œ×¢ ${i+1} (×¡×´×)`;
      box.appendChild(input);
    }
    inputsCard.classList.remove("hidden");
  }

  function isPointInPoly(p, poly) {
    let inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      if (((poly[i].y > p.y) !== (poly[j].y > p.y)) &&
          (p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) inside = !inside;
    }
    return inside;
  }

  function drawLayout(canvas, reportEl, pts, sideValues, tW, tH) {
    const W = 600, H = 500;
    canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext("2d");
    
    const xs = pts.map(p=>p.x), ys=pts.map(p=>p.y);
    const minX=Math.min(...xs), maxX=Math.max(...xs), minY=Math.min(...ys), maxY=Math.max(...ys);
    const pad=50, scale = Math.min((W-2*pad)/(maxX-minX), (H-2*pad)/(maxY-minY));
    const tx = (px) => pad + (px - minX)*scale, ty = (py) => pad + (py - minY)*scale;

    // ×¤×¨×™×¡×ª ××¨×™×—×™×
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(tx(pts[0].x), ty(pts[0].y));
    for(let i=1; i<pts.length; i++) ctx.lineTo(tx(pts[i].x), ty(pts[i].y));
    ctx.closePath();
    ctx.clip();

    let count = 0;
    ctx.strokeStyle = "#e2e8f0";
    for(let gx = minX; gx < maxX; gx += tW){
      for(let gy = minY; gy < maxY; gy += tH){
        ctx.strokeRect(tx(gx), ty(gy), tW*scale, tH*scale);
        const tests = [{x:gx,y:gy},{x:gx+tW,y:gy},{x:gx,y:gy+tH},{x:gx+tW,y:gy+tH},{x:gx+tW/2,y:gy+tH/2}];
        if(tests.some(p => isPointInPoly(p, pts))) count++;
      }
    }
    ctx.restore();

    // ×¦×™×•×¨ ×§×™×¨×•×ª
    ctx.strokeStyle = "#2563eb"; ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(tx(pts[0].x), ty(pts[0].y));
    for(let i=1; i<pts.length; i++) ctx.lineTo(tx(pts[i].x), ty(pts[i].y));
    ctx.closePath(); ctx.stroke();

    // ×”×•×¡×¤×ª ××™×“×•×ª ×¦×œ×¢×•×ª
    ctx.fillStyle = "#1e293b";
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "center";
    for(let i=0; i<edgeCount; i++){
      let p1 = pts[i], p2 = pts[i+1];
      let mx = tx((p1.x + p2.x)/2), my = ty((p1.y + p2.y)/2);
      // ×”×¡×˜×” ×§×œ×” ×©×œ ×”×˜×§×¡×˜ ×©×œ× ×™×”×™×” ×¢×œ ×”×§×•
      ctx.fillText(sideValues[i] + " ×¡×´×", mx, my - 8);
    }

    reportEl.innerHTML = `×›××•×ª: ${count} ×™×—×™×“×•×ª`;
  }

  function buildFinal(){
    const values = [...document.querySelectorAll("#inputs input")].map(i=>Number(i.value));
    const tW = Number(document.getElementById("tileW").value);
    const tH = Number(document.getElementById("tileH").value);
    
    if(values.some(v => v<=0) || tW<=0 || tH<=0) return alert("×”×–×Ÿ ××™×“×•×ª ×ª×§×™× ×•×ª");

    let pts = [{x:0,y:0}];
    let x=0, y=0;
    for(let i=0; i<edgeCount; i++){
      x += edgeDirs[i].dx * values[i];
      y += edgeDirs[i].dy * values[i];
      pts.push({x,y});
    }

    let areaCm2 = 0;
    for (let i = 0; i < pts.length - 1; i++) {
      areaCm2 += (pts[i].x * pts[i+1].y) - (pts[i+1].x * pts[i].y);
    }
    areaCm2 = Math.abs(areaCm2) / 2;

    drawLayout(document.getElementById("resultA"), document.getElementById("reportA"), pts, values, tW, tH);
    drawLayout(document.getElementById("resultB"), document.getElementById("reportB"), pts, values, tH, tW);

    document.getElementById("generalReport").innerHTML = `
      <b>×¡×™×›×•× ××™×“×•×ª:</b> ×”×™×§×£ ${values.reduce((a,b)=>a+b,0)} ×¡"× | ×©×˜×— ${(areaCm2/10000).toFixed(2)} ×"×¨
    `;
    resultCard.classList.remove("hidden");
    
    // ×’×œ×™×œ×” ××•×˜×•××˜×™×ª ×œ×ª×•×¦××”
    resultCard.scrollIntoView({ behavior: 'smooth' });
  }

  btnShot.addEventListener("click", () => {
    try {
      captureToCanvas();
      detectAndNumberEdges();
      setStatus("×–×™×”×•×™ ×”×•×©×œ× âœ…", "good");
    } catch(e) { setStatus(e.message, "bad"); }
  });

  btnRestart.addEventListener("click", () => location.reload());
  btnBuild.addEventListener("click", buildFinal);

  // ×œ×•×’×™×§×ª ×–×•× ××ª×•×§× ×ª ×©×œ× ×—×•×¡××ª ×’×œ×™×œ×”
  [document.getElementById("containerA"), document.getElementById("containerB")].forEach(cont => {
    cont.addEventListener('touchstart', e => { 
      if(e.touches.length === 2) {
        initialDist = Math.hypot(e.touches[0].pageX-e.touches[1].pageX, e.touches[0].pageY-e.touches[1].pageY);
      }
    });
    cont.addEventListener('touchmove', e => {
      if(e.touches.length === 2){
        e.preventDefault(); // ××•× ×¢ ×’×œ×™×œ×” ×¨×§ ×›×©××‘×¦×¢×™× ×–×•× ×¢× 2 ××¦×‘×¢×•×ª
        let d = Math.hypot(e.touches[0].pageX-e.touches[1].pageX, e.touches[0].pageY-e.touches[1].pageY);
        currentScale = Math.min(Math.max(0.5, currentScale * (d/initialDist)), 4);
        cont.querySelector('canvas').style.transform = `scale(${currentScale})`;
        initialDist = d;
      }
    }, {passive:false});
  });

  startCamera();
</script>

</body>
</html>
