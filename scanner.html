<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>×¡×•×¨×§ Pro - ×¨×‘ ×¢××•×“×™×</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://docs.opencv.org/4.7.0/opencv.js"></script>

  <style>
    * { box-sizing: border-box; }
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; color: #fff; font-family: system-ui, sans-serif; }
    .app { display: flex; flex-direction: column; height: 100dvh; }

    #debug { background: #1a1a1a; color: #0f0; font-size: 12px; padding: 8px; text-align: center; border-bottom: 1px solid #333; }

    .viewer { flex: 1; min-height: 0; position: relative; display: flex; align-items: center; justify-content: center; background: #000; }
    video, canvas { max-width: 100%; max-height: 100%; object-fit: contain; }
    #canvasOutput { display: none; }

    .footer {
      flex: 0 0 auto;
      background: #111;
      border-top: 1px solid #222;
      padding: 10px 12px calc(12px + env(safe-area-inset-bottom));
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
      justify-content: center;
    }

    #msg { text-align: center; font-size: 16px; }

    .snap-btn {
      width: 78px; height: 78px;
      background: #fff;
      border-radius: 50%;
      border: 6px solid #333;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: 0.15s;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .snap-btn:active { transform: scale(0.92); background: #ddd; }
    .snap-inner { width: 56px; height: 56px; border-radius: 50%; border: 2px solid #000; }

    .row { width: min(720px, 96%); display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap; }
    .pill { font-size: 13px; padding: 6px 10px; border: 1px solid #444; border-radius: 999px; background: #0d0d0d; color: #ddd; }

    .btn { padding: 12px 14px; border-radius: 12px; border: none; font-weight: 800; font-size: 15px; cursor: pointer; background: #333; color: #fff; }
    .btn:active { transform: scale(0.98); }
    .btn-green { background: #25d366; color: #fff; }
    .btn-blue { background: #0b5ed7; color: #fff; }
    .btn-red { background: #b02a37; color: #fff; }

    /* thumbnails */
    #thumbs {
      width: min(720px, 96%);
      display: none;
      gap: 8px;
      overflow-x: auto;
      padding: 6px 2px;
      justify-content: flex-start;
      align-items: center;
    }
    .thumb {
      height: 56px;
      border-radius: 10px;
      border: 1px solid #333;
      background: #000;
      flex: 0 0 auto;
      cursor: pointer;
    }

    #loader { position: fixed; inset: 0; background: #000; z-index: 99; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    .spinner { width: 40px; height: 40px; border: 4px solid #222; border-top: 4px solid #007bff; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Preview Modal */
    #previewModal {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.92);
      z-index: 999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px 12px calc(14px + env(safe-area-inset-bottom));
    }
    #previewWrap {
      width: min(980px, 100%);
      height: min(86vh, 100%);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #previewTop {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    #previewTitle {
      font-weight: 800;
      font-size: 15px;
      color: #fff;
    }
    #previewImg {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 12px;
      border: 1px solid #333;
      background: #000;
    }
  </style>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <p>×˜×•×¢×Ÿ ××ª ×”××¢×¨×›×ª...</p>
  </div>

  <div class="app">
    <div id="debug">Log: ×××ª×™×Ÿ ×œ-OpenCV</div>

    <div class="viewer">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvasOutput"></canvas>
    </div>

    <div class="footer">
      <div id="msg">×›×•×•×Ÿ ××œ ×”×“×£ ×•×œ×—×¥ ×¦×™×œ×•×</div>

      <div class="row" id="rowCapture">
        <div class="pill" id="pagesInfo">×¢××•×“×™×: 0</div>

        <button class="btn" id="modeBtn">ğŸ©¶ ××¤×•×¨</button>

        <div class="snap-btn" id="snapBtn" aria-label="×¦×™×œ×•×">
          <div class="snap-inner"></div>
        </div>

        <button class="btn btn-red" id="resetBtn">××™×¤×•×¡</button>
      </div>

      <div id="thumbs"></div>

      <div class="row" id="rowActions" style="display:none">
        <button class="btn btn-blue" id="addPageBtn">â• ×”×•×¡×£ ×¢××•×“</button>
        <button class="btn btn-green" id="makePdfBtn">ğŸ“© ×©×œ×— PDF</button>
      </div>
    </div>
  </div>

  <div id="previewModal">
    <div id="previewWrap">
      <div id="previewTop">
        <div id="previewTitle">×ª×¦×•×’×” ××§×“×™××”</div>
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn btn-red" id="deletePageBtn">ğŸ—‘ï¸ ××—×§ ×¢××•×“</button>
          <button class="btn" id="closePreviewBtn">×¡×’×•×¨ âœ–ï¸</button>
        </div>
      </div>
      <img id="previewImg" alt="preview" />
    </div>
  </div>

<script>
  const log = (m) => document.getElementById('debug').innerText = "Log: " + m;

  const video = document.getElementById('video');
  const canvas = document.getElementById('canvasOutput');

  const loader = document.getElementById('loader');
  const msg = document.getElementById('msg');

  const snapBtn = document.getElementById('snapBtn');
  const resetBtn = document.getElementById('resetBtn');

  const pagesInfo = document.getElementById('pagesInfo');
  const thumbs = document.getElementById('thumbs');
  const rowActions = document.getElementById('rowActions');
  const addPageBtn = document.getElementById('addPageBtn');
  const makePdfBtn = document.getElementById('makePdfBtn');

  const previewModal = document.getElementById('previewModal');
  const previewImg = document.getElementById('previewImg');
  const previewTitle = document.getElementById('previewTitle');
  const closePreviewBtn = document.getElementById('closePreviewBtn');
  const deletePageBtn = document.getElementById('deletePageBtn');

  const modeBtn = document.getElementById('modeBtn');
  let scanMode = "bw";

  modeBtn.addEventListener('click', () => {
    scanMode = (scanMode === "bw") ? "gray" : "bw";
    modeBtn.innerText = (scanMode === "bw") ? "ğŸ©¶ ××¤×•×¨" : "â¬› ×©×—×•×¨-×œ×‘×Ÿ";
    log("××¦×‘ ×¡×¨×™×§×”: " + (scanMode === "bw" ? "×©×—×•×¨-×œ×‘×Ÿ" : "××¤×•×¨"));
  });

  let cvReady = false;
  let cameraReady = false;
  let streamRef = null;

  const pages = [];
  let previewIndex = -1;

  snapBtn.addEventListener('click', processDocAndStore);
  resetBtn.addEventListener('click', () => location.reload());
  addPageBtn.addEventListener('click', backToCamera);
  makePdfBtn.addEventListener('click', sendMultiPagePdf);

  closePreviewBtn.addEventListener('click', closePreview);
  previewModal.addEventListener('click', (e) => { if (e.target === previewModal) closePreview(); });
  deletePageBtn.addEventListener('click', deleteCurrentPreviewPage);

  cv.onRuntimeInitialized = async () => {
    cvReady = true;
    log("OpenCV ××•×›×Ÿ, ×¤×•×ª×— ××¦×œ××”...");
    await initCamera();
  };

  async function initCamera() {
    try {
      streamRef = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio: false
      });

      video.srcObject = streamRef;

      await new Promise((resolve) => {
        const onReady = () => {
          if (video.videoWidth > 0 && video.videoHeight > 0) {
            video.removeEventListener('loadedmetadata', onReady);
            video.removeEventListener('canplay', onReady);
            resolve();
          }
        };
        video.addEventListener('loadedmetadata', onReady);
        video.addEventListener('canplay', onReady);
      });

      cameraReady = true;
      loader.style.display = "none";
      log(`××¢×¨×›×ª ××•×›× ×” âœ… (${video.videoWidth}x${video.videoHeight})`);
    } catch (e) {
      loader.style.display = "none";
      log("×©×’×™××” ×‘×¤×ª×™×—×ª ××¦×œ××”");
      alert("×œ× ×”×¦×œ×—×ª×™ ×œ×¤×ª×•×— ××¦×œ××”.");
      console.error(e);
    }
  }

  function grabFrameToMat() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    const tmp = document.createElement('canvas');
    tmp.width = w;
    tmp.height = h;
    const ctx = tmp.getContext('2d', { willReadFrequently: true });
    ctx.drawImage(video, 0, 0, w, h);
    return cv.imread(tmp);
  }

  function backToCamera() {
    canvas.style.display = 'none';
    video.style.display = 'block';
    msg.innerText = "×›×•×•×Ÿ ××œ ×”×“×£ ×•×œ×—×¥ ×¦×™×œ×•×";
    log("×—×–×¨×” ×œ××¦×œ××”");
  }

  function updatePagesUI() {
    pagesInfo.innerText = `×¢××•×“×™×: ${pages.length}`;
    rowActions.style.display = pages.length > 0 ? 'flex' : 'none';
    thumbs.style.display = pages.length > 0 ? 'flex' : 'none';
    thumbs.innerHTML = "";
    pages.forEach((dataUrl, idx) => {
      const img = document.createElement('img');
      img.src = dataUrl;
      img.className = "thumb";
      img.title = `×¢××•×“ ${idx+1}`;
      img.addEventListener('click', () => openPreview(idx));
      thumbs.appendChild(img);
    });
  }

  function openPreview(index) {
    previewIndex = index;
    previewImg.src = pages[index];
    previewTitle.innerText = `×ª×¦×•×’×” ××§×“×™××” - ×¢××•×“ ${index+1} ××ª×•×š ${pages.length}`;
    previewModal.style.display = 'flex';
  }

  function closePreview() {
    previewModal.style.display = 'none';
    previewIndex = -1;
  }

  function deleteCurrentPreviewPage() {
    if (previewIndex < 0 || previewIndex >= pages.length) return;
    pages.splice(previewIndex, 1);
    if (pages.length === 0) {
      closePreview();
      updatePagesUI();
      backToCamera();
      return;
    }
    if (previewIndex >= pages.length) previewIndex = pages.length - 1;
    updatePagesUI();
    openPreview(previewIndex);
  }

  // ------------------------------
  // âœ… ×—×“×©: ×–×™×”×•×™ ×“×£ + ×™×™×©×•×¨ ×¤×¨×¡×¤×§×˜×™×‘×” (×›××• ×¡×•×¨×§)
  // ------------------------------

  function dist(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function orderPoints(pts) {
    // pts: [{x,y},{x,y},{x,y},{x,y}]
    // ××—×–×™×¨: [tl, tr, br, bl]
    const sum = pts.map(p => p.x + p.y);
    const diff = pts.map(p => p.x - p.y);

    const tl = pts[sum.indexOf(Math.min(...sum))];
    const br = pts[sum.indexOf(Math.max(...sum))];
    const tr = pts[diff.indexOf(Math.max(...diff))];
    const bl = pts[diff.indexOf(Math.min(...diff))];
    return [tl, tr, br, bl];
  }

  function fourPointTransform(src, quadPts /* array of 4 points in src coords */) {
    const [tl, tr, br, bl] = orderPoints(quadPts);

    const widthA = dist(br, bl);
    const widthB = dist(tr, tl);
    const maxW = Math.max(widthA, widthB);

    const heightA = dist(tr, br);
    const heightB = dist(tl, bl);
    const maxH = Math.max(heightA, heightB);

    const dstW = Math.max(1, Math.round(maxW));
    const dstH = Math.max(1, Math.round(maxH));

    const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
      tl.x, tl.y,
      tr.x, tr.y,
      br.x, br.y,
      bl.x, bl.y
    ]);

    const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
      0, 0,
      dstW - 1, 0,
      dstW - 1, dstH - 1,
      0, dstH - 1
    ]);

    const M = cv.getPerspectiveTransform(srcTri, dstTri);
    const warped = new cv.Mat();
    const dsize = new cv.Size(dstW, dstH);
    cv.warpPerspective(src, warped, M, dsize, cv.INTER_LINEAR, cv.BORDER_REPLICATE);

    srcTri.delete(); dstTri.delete(); M.delete();
    return warped;
  }

  function detectDocumentQuad(srcRGBA) {
    // ×¢×•×‘×“ ×¢×œ ×’×¨×¡×” ××•×§×˜× ×ª ×‘×©×‘×™×œ ××”×™×¨×•×ª, ×•××– ××—×–×™×¨ × ×§×•×“×•×ª ×‘×§×•××•×¨×“×™× ×˜×•×ª ×”××§×•×¨
    const maxSide = 900; // ××™×–×•×Ÿ ××”×™×¨×•×ª/×“×™×•×§
    const w0 = srcRGBA.cols, h0 = srcRGBA.rows;
    const scale = Math.min(1, maxSide / Math.max(w0, h0));
    let small = srcRGBA;
    let resized = null;

    if (scale < 1) {
      resized = new cv.Mat();
      cv.resize(srcRGBA, resized, new cv.Size(Math.round(w0 * scale), Math.round(h0 * scale)), 0, 0, cv.INTER_AREA);
      small = resized;
    }

    let gray = new cv.Mat();
    cv.cvtColor(small, gray, cv.COLOR_RGBA2GRAY);

    let blur = new cv.Mat();
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

    let edges = new cv.Mat();
    cv.Canny(blur, edges, 60, 180);

    // ××—×–×§ ×§×•×•×™× ×›×“×™ ×œ×¡×’×•×¨ "×¤×¢×¨×™×"
    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5,5));
    cv.dilate(edges, edges, kernel);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let best = null;
    let bestArea = 0;

    for (let i = 0; i < contours.size(); i++) {
      const cnt = contours.get(i);
      const area = cv.contourArea(cnt);
      if (area < 1000) { cnt.delete(); continue; }

      const peri = cv.arcLength(cnt, true);
      const approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

      if (approx.rows === 4 && area > bestArea) {
        if (best) best.delete();
        best = approx.clone();
        bestArea = area;
      }

      approx.delete();
      cnt.delete();
    }

    // × ×™×§×•×™
    gray.delete(); blur.delete(); edges.delete(); kernel.delete();
    contours.delete(); hierarchy.delete();
    if (resized) resized.delete();

    if (!best) return null;

    // best ×”×•× Mat ×©×œ 4 × ×§×•×“×•×ª ×‘-scale ×©×œ small
    // ×”××¨×” ×œ××¢×¨×š × ×§×•×“×•×ª ×‘×§×•××•×¨×“×™× ×˜×•×ª ××§×•×¨
    const pts = [];
    const data = best.data32S; // approxPolyDP ××—×–×™×¨ int
    // data ×‘×¤×•×¨××˜ [x0,y0,x1,y1,...]
    for (let i = 0; i < 8; i += 2) {
      const x = data[i];
      const y = data[i + 1];
      pts.push({ x: x / scale, y: y / scale });
    }
    best.delete();
    return pts;
  }

  function processDocAndStore() {
    if (!cvReady || !cameraReady) return;

    let src = null, warped = null, out = null;
    let gray2 = null, blur2 = null;

    try {
      log("××¢×‘×“... × × ×œ× ×œ×”×–×™×–");
      src = grabFrameToMat(); // RGBA

      // âœ… × ×¡×” ×œ×–×”×•×ª ×“×£ ×•×œ×—×ª×•×š ××•×ª×•
      const quad = detectDocumentQuad(src);
      if (quad) {
        warped = fourPointTransform(src, quad); // ×¢×“×™×™×Ÿ RGBA
      } else {
        // fallback: ×›××• ×©×”×™×” (×œ× ×œ×©×‘×•×¨ ×›×œ×•× ×× ×œ× ×–×•×”×” ×“×£)
        warped = src.clone();
        log("×œ× ×–×•×”×” ×“×£ ×‘×¦×•×¨×” ×˜×•×‘×” â€” × ×©××¨ fallback");
      }

      // ×¢×›×©×™×• ××¤×¢×™×œ×™× "×¡×¨×™×§×”" ×¨×§ ×¢×œ ×”×“×£ (warped)
      gray2 = new cv.Mat();
      cv.cvtColor(warped, gray2, cv.COLOR_RGBA2GRAY);

      blur2 = new cv.Mat();
      cv.GaussianBlur(gray2, blur2, new cv.Size(3, 3), 0);

      out = new cv.Mat();
      if (scanMode === "gray") {
        out = blur2.clone();
      } else {
        cv.adaptiveThreshold(blur2, out, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 12);
      }

      canvas.width = out.cols;
      canvas.height = out.rows;
      cv.imshow(canvas, out);

      video.style.display = 'none';
      canvas.style.display = 'block';

      const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
      pages.push(dataUrl);

      msg.innerText = `× ×¡×¨×§ ×¢××•×“ ${pages.length}.`;
      updatePagesUI();
      log("×”×¡×¨×™×§×” × ×©××¨×” (×œ×œ× ×¨×§×¢)");

    } catch (err) {
      log("×©×’×™××” ×‘×¢×™×‘×•×“");
      console.error(err);
    } finally {
      // × ×™×§×•×™ ×–×™×›×¨×•×Ÿ
      if (src) src.delete();
      if (warped) warped.delete();
      if (gray2) gray2.delete();
      if (blur2) blur2.delete();
      if (out) out.delete();
    }
  }

  async function sendMultiPagePdf() {
    if (pages.length === 0) return;

    try {
      log("××›×™×Ÿ PDF ×œ×©×™×ª×•×£...");
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'p' });
      const pageW = 210, pageH = 297;

      for (let i = 0; i < pages.length; i++) {
        if (i > 0) pdf.addPage();
        const imgData = pages[i];
        const dims = await new Promise((resolve) => {
          const im = new Image();
          im.onload = () => resolve({ w: im.width, h: im.height });
          im.src = imgData;
        });
        const imgRatio = dims.w / dims.h;
        let drawW = pageW;
        let drawH = drawW / imgRatio;
        if (drawH > pageH) { drawH = pageH; drawW = drawH * imgRatio; }
        const x = (pageW - drawW) / 2;
        const y = (pageH - drawH) / 2;
        pdf.addImage(imgData, 'JPEG', x, y, drawW, drawH, undefined, 'FAST');
      }

      const blob = pdf.output('blob');
      const fileName = `×¡×¨×™×§×”_${new Date().toLocaleDateString('he-IL').replace(/\//g,'-')}.pdf`;
      const file = new File([blob], fileName, { type: "application/pdf" });

      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: '×”×¡×¨×™×§×” ×©×œ×™',
          text: '××¦×•×¨×£ ×”×§×•×‘×¥ ×©×¡×¨×§×ª×™'
        });
        log("×ª×¤×¨×™×˜ ×©×™×ª×•×£ × ×¤×ª×—");
      } else {
        pdf.save(fileName);
        log("×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×©×™×ª×•×£ ×™×©×™×¨ - ×”×§×•×‘×¥ ×”×•×¨×“");
      }
    } catch (e) {
      log("×”×©×™×ª×•×£ ×‘×•×˜×œ");
    }
  }
</script>
</body>
</html>
charles.s
