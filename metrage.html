<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>×©×¨×˜×•×˜ ×—×›× - ×¨×¦×¤×” ×•×§×™×¨×•×ª ×‘×‘×ª ××—×ª</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script async src="https://docs.opencv.org/4.7.0/opencv.js" onload="__onCvScriptLoaded()"></script>

<style>
  :root{--bg:#f4f6f9;--card:#fff;--text:#111827;--muted:#6b7280;--primary:#2563eb;--danger:#dc2626;--line:#e5e7eb;}
  *{box-sizing:border-box}
  body{margin:0;padding:16px;font-family:system-ui,Arial;background:var(--bg);color:var(--text); overflow-y: auto;}
  .wrap{max-width:980px;margin:0 auto}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;margin-bottom:14px;box-shadow:0 10px 25px rgba(0,0,0,.08)}
  h2{margin:0 0 10px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{
    width:100%; padding:14px 16px; border:0; border-radius:12px;
    background:var(--primary); color:#fff; font-size:18px; cursor:pointer;
  }
  .btn.secondary{background:#111827}
  .btn.success{background:#059669}
  .btn.danger{background:var(--danger)}
  video,canvas{width:100%;border-radius:12px;border:1px solid var(--line);background:#fff}
  .hidden{display:none}
  .input-group { margin-bottom: 15px; padding: 12px; border-radius: 12px; background: #fff; border-width: 5px; border-style: solid; }
  input { width:100%; padding:14px; border:1px solid #ddd; border-radius:8px; font-size:20px; outline:none; font-weight: bold; }
  input.auto-filled { background-color: #f0fff4; border-color: #22c55e; color: #15803d; }
  .result-container-single { width: 100%; background: #fff; border: 1px solid var(--line); border-radius: 12px; overflow: hidden; touch-action: none; margin-bottom: 15px; position: relative; }
  .result-canvas { width: 100%; height: auto; display: block; transform-origin: center center; transition: transform 0.1s; }
  .tile-label-header { padding: 10px; background: #f8fafc; border-bottom: 1px solid var(--line); font-weight: bold; color: var(--primary); text-align: center; }
  .tile-label-footer { padding: 10px; background: #f8fafc; border-top: 1px solid var(--line); font-weight: bold; color: var(--primary); text-align: center; }
  .status{ padding:10px 12px; border-radius:12px; border:1px solid var(--line); background:#fff; font-size:14px; margin-bottom:10px;}
  .status.good{border-color:#22c55e; color:#15803d; font-weight:bold;}
</style>
</head>

<body>
<div class="wrap">

  <div class="card" id="settingsScreen">
    <h2>ğŸ“ ×”×’×“×¨×•×ª ×¤×¨×•×™×§×˜</h2>
    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <div style="flex:1"><label>××¨×™×— ×¨×¦×¤×” W</label><input id="floorTileW" type="number" placeholder="×¡×´×"></div>
        <div style="flex:1"><label>××¨×™×— ×¨×¦×¤×” H</label><input id="floorTileH" type="number" placeholder="×¡×´×"></div>
    </div>
    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <div style="flex:1"><label>××¨×™×— ×§×™×¨ W</label><input id="wallTileW" type="number" placeholder="×¡×´×"></div>
        <div style="flex:1"><label>××¨×™×— ×§×™×¨ H</label><input id="wallTileH" type="number" placeholder="×¡×´×"></div>
    </div>
    <div style="margin-bottom: 20px;">
        <label>×’×•×‘×” ×ª×§×¨×” (×—×“ ×¤×¢××™)</label>
        <input id="ceilingHeight" type="number" placeholder="×¡×´× (×œ××©×œ 250)">
    </div>
    <button onclick="saveSettings()" class="btn success">×”××©×š ×œ××“×™×“×ª ×¨×¦×¤×” â¡ï¸</button>
    <button onclick="loadSavedProject()" id="btnResume" class="btn secondary hidden" style="margin-top:10px;">×˜×¢×Ÿ ×¤×¨×•×™×§×˜ ××—×¨×•×Ÿ ××”×–×™×›×¨×•×Ÿ</button>
  </div>

  <div id="measurementSection" class="hidden">
    <div class="card">
        <h2>1ï¸âƒ£ ××“×™×“×ª ×¨×¦×¤×”</h2>
        <div id="statusBox" class="status">×˜×•×¢×Ÿ OpenCV...</div>
        <video id="video" autoplay playsinline></video>
        <canvas id="photo" class="hidden"></canvas>
        <div class="row" style="margin-top:12px">
          <button id="btnShot" class="btn">ğŸ“¸ ×¦×œ× ×•×–×”×”</button>
          <button id="btnRect" class="btn success">â¬œ ××œ×‘×Ÿ ××”×™×¨</button>
          <button onclick="location.reload()" class="btn secondary">ğŸ”™ ×—×–×•×¨</button>
        </div>
    </div>

    <div class="card hidden" id="previewCard">
        <h2>2ï¸âƒ£ ×œ×—×¥ ×¢×œ ××¡×¤×¨ ×œ××¢×‘×¨ ×œ×ª×</h2>
        <canvas id="overlay"></canvas>
    </div>

    <div class="card hidden" id="inputsCard">
        <div id="inputs"></div>
        <button onclick="processFloorResults()" class="btn">ğŸ“ ×‘× ×” ×•×”×©×•×•×” ×›×™×•×•× ×™×</button>
    </div>

    <div class="card hidden" id="floorResultCard">
        <h2>3ï¸âƒ£ ×‘×—×¨ ×›×™×•×•×Ÿ ×œ×¨×¦×¤×”</h2>
        <div class="result-container-single">
            <div class="tile-label-header" id="floorHeaderA">××•×¤×¦×™×” ×'</div>
            <canvas id="floorResA" class="result-canvas"></canvas>
            <div id="floorReportA" class="tile-label-footer"></div>
            <button onclick="selectFloorOrientation('A')" class="btn success" style="border-radius:0;">×‘×—×¨ ×›×™×•×•×Ÿ ×–×” ×œ×¨×¦×¤×”</button>
        </div>
        <div class="result-container-single">
            <div class="tile-label-header" id="floorHeaderB">××•×¤×¦×™×” ×‘'</div>
            <canvas id="floorResB" class="result-canvas"></canvas>
            <div id="floorReportB" class="tile-label-footer"></div>
            <button onclick="selectFloorOrientation('B')" class="btn success" style="border-radius:0;">×‘×—×¨ ×›×™×•×•×Ÿ ×–×” ×œ×¨×¦×¤×”</button>
        </div>
    </div>

    <div class="card hidden" id="wallLockCard">
        <h2>4ï¸âƒ£ ×‘×—×¨ ×›×™×•×•×Ÿ ××¨×™×— ×œ×§×™×¨×•×ª (×™×™× ×¢×œ ×œ×›×œ ×”×§×™×¨×•×ª)</h2>
        <div class="result-container-single">
            <div class="tile-label-header" id="wallHeaderA">××•×¤×¦×™×” ×' (×©×•×›×‘)</div>
            <canvas id="wallResA" class="result-canvas"></canvas>
            <div id="wallReportA" class="tile-label-footer"></div>
            <button onclick="lockWallOrientation('A')" class="btn success" style="border-radius:0;">×‘×—×¨ ×›×™×•×•×Ÿ ×–×” ×œ×›×œ ×”×§×™×¨×•×ª</button>
        </div>
        <div class="result-container-single">
            <div class="tile-label-header" id="wallHeaderB">××•×¤×¦×™×” ×‘' (×¢×•××“)</div>
            <canvas id="wallResB" class="result-canvas"></canvas>
            <div id="wallReportB" class="tile-label-footer"></div>
            <button onclick="lockWallOrientation('B')" class="btn success" style="border-radius:0;">×‘×—×¨ ×›×™×•×•×Ÿ ×–×” ×œ×›×œ ×”×§×™×¨×•×ª</button>
        </div>
    </div>
  </div>

  <div id="finalDashboard" class="card hidden">
      <div id="pdfContent" style="background:white; padding:15px; direction:rtl;">
          <h1 style="text-align:center; color:#2563eb;">×“×•×— ×¤×¨×•×™×§×˜ ××¨×•×›×–</h1>
          <div id="summaryBox" style="background:#e0f2fe; padding:12px; border-radius:10px; margin-bottom:15px;"></div>
          <div id="itemsDetail"></div>
      </div>
      <button onclick="sharePDF()" class="btn success">ğŸ“„ ×©×œ×— ×“×•×— ××œ× (PDF)</button>
      <button onclick="clearAll()" class="btn danger" style="margin-top:10px;">ğŸ—‘ï¸ ××—×§ ×”×›×œ ×•×”×ª×—×œ ×—×“×©</button>
  </div>

</div>

<script>
  const edgeColors = ['#FF0000', '#059669', '#2563eb', '#7c3aed', '#ea580c', '#db2777', '#0891b2', '#ca8a04'];
  let video = document.getElementById("video"), photo = document.getElementById("photo"), overlay = document.getElementById("overlay");
  let cvReady = false, videoReady = false, polyPts = [], edgeDirs = [], numberHitZones = [];
  
  let settings = {};
  let projectData = { floor: null, walls: [], floorOrientation: null, wallOrientation: null };

  window.onload = () => {
    if(localStorage.getItem('smartProject')) document.getElementById('btnResume').classList.remove('hidden');
  };

  function __onCvScriptLoaded(){
    const wait = setInterval(() => { if (window.cv && cv.Mat) { cvReady = true; setStatus("××¢×¨×›×ª ××•×›× ×” âœ…", "good"); document.getElementById("btnShot").disabled = !videoReady; clearInterval(wait); } }, 100);
  }

  async function startCamera(){
    try {
      let s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: 1280, height: 720 } });
      video.srcObject = s; videoReady = true; if(cvReady) document.getElementById("btnShot").disabled = false;
    } catch(e) { setStatus("×©×’×™××ª ××¦×œ××”", "bad"); }
  }

  function setStatus(m, t){ let b = document.getElementById("statusBox"); b.textContent = m; b.className = "status " + (t||""); }

  function saveSettings() {
    settings = {
        fW: Number(document.getElementById('floorTileW').value),
        fH: Number(document.getElementById('floorTileH').value),
        wW: Number(document.getElementById('wallTileW').value),
        wH: Number(document.getElementById('wallTileH').value),
        h: Number(document.getElementById('ceilingHeight').value)
    };
    if(!settings.fW || !settings.fH) return alert("×—×•×‘×” ×œ×”×–×™×Ÿ ××™×“×•×ª ××¨×™×—×™ ×¨×¦×¤×”");
    document.getElementById('settingsScreen').classList.add('hidden');
    document.getElementById('measurementSection').classList.remove('hidden');
    startCamera();
  }

  function loadSavedProject() {
    projectData = JSON.parse(localStorage.getItem('smartProject'));
    settings = projectData.settings;
    document.getElementById('settingsScreen').classList.add('hidden');
    showDashboard();
  }

  document.getElementById("btnRect").onclick = () => {
    polyPts = [{x:100,y:50},{x:500,y:50},{x:500,y:350},{x:100,y:350}];
    buildInputsInterface(false);
  };

  document.getElementById("btnShot").onclick = () => {
    photo.width = video.videoWidth; photo.height = video.videoHeight;
    photo.getContext("2d").drawImage(video, 0, 0);
    let src = cv.imread(photo), gray = new cv.Mat(), edges = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); cv.Canny(gray, edges, 40, 120);
    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
    cv.dilate(edges, edges, kernel);
    let cnts = new cv.MatVector(), hi = new cv.Mat();
    cv.findContours(edges, cnts, hi, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    let big = null, maxA = 0;
    for(let i=0; i<cnts.size(); i++){ let a = cv.contourArea(cnts.get(i)); if(a > maxA){ maxA = a; big = cnts.get(i); } }
    if(!big) return alert("×œ× ×–×•×”×ª×” ×¦×•×¨×”.");
    let approx = new cv.Mat(); cv.approxPolyDP(big, approx, 0.015 * cv.arcLength(big, true), true);
    polyPts = []; for(let i=0; i<approx.rows; i++) polyPts.push({x: approx.intPtr(i,0)[0], y: approx.intPtr(i,0)[1]});
    
    // ×¡×™×“×•×¨ ×©×¢×•×Ÿ
    let area = 0; for (let i = 0; i < polyPts.length; i++) { let p1 = polyPts[i], p2 = polyPts[(i + 1) % polyPts.length]; area += (p2.x - p1.x) * (p2.y + p1.y); }
    if (area < 0) polyPts.reverse();
    let topIdx = 0, minY = polyPts[0].y;
    for (let i = 1; i < polyPts.length; i++) { if (polyPts[i].y < minY) { minY = polyPts[i].y; topIdx = i; } }
    polyPts = polyPts.slice(topIdx).concat(polyPts.slice(0, topIdx));

    overlay.width = photo.width; overlay.height = photo.height;
    buildInputsInterface(true);
    src.delete(); gray.delete(); edges.delete(); cnts.delete(); hi.delete(); approx.delete(); kernel.delete();
  };

  function buildInputsInterface(withPhoto) {
    let inpBox = document.getElementById("inputs"); inpBox.innerHTML = "";
    numberHitZones = []; edgeDirs = [];
    let octx = overlay.getContext("2d");
    if(!withPhoto) { overlay.width = 600; overlay.height = 400; octx.fillStyle = "#fff"; octx.fillRect(0,0,600,400); } else octx.drawImage(photo, 0, 0);
    for(let i=0; i<polyPts.length; i++){
      let p1 = polyPts[i], p2 = polyPts[(i+1)%polyPts.length];
      let color = edgeColors[i % edgeColors.length];
      octx.strokeStyle = color; octx.lineWidth = 12;
      octx.beginPath(); octx.moveTo(p1.x, p1.y); octx.lineTo(p2.x, p2.y); octx.stroke();
      let mx = (p1.x+p2.x)/2, my = (p1.y+p2.y)/2;
      numberHitZones.push({ x: mx, y: my, radius: 50, id: `inp-${i}` });
      octx.fillStyle = "white"; octx.beginPath(); octx.arc(mx, my, 40, 0, 7); octx.fill();
      octx.fillStyle = color; octx.font = "bold 55px Arial"; octx.textAlign="center"; octx.textBaseline="middle"; octx.fillText(i+1, mx, my);
      edgeDirs.push(Math.abs(p2.x-p1.x) >= Math.abs(p2.y-p1.y) ? {dx: Math.sign(p2.x-p1.x)||1, dy:0} : {dx:0, dy:Math.sign(p2.y-p1.y)||1});
      inpBox.innerHTML += `<div class="input-group" style="border-color: ${color}"><label style="color: ${color}">×¦×œ×¢ ${i+1}</label><input type="number" id="inp-${i}" class="side-val" oninput="liveSolve()"></div>`;
    }
    document.getElementById("previewCard").classList.remove("hidden");
    document.getElementById("inputsCard").classList.remove("hidden");
    document.getElementById("inputsCard").scrollIntoView({behavior: "smooth"});
  }

  function liveSolve() {
    let inputs = [...document.getElementsByClassName("side-val")];
    let sVals = inputs.map(i => (i.value === "" || i.classList.contains('auto-filled')) ? null : Number(i.value));
    let horiz = [], vert = [];
    for(let i=0; i<edgeDirs.length; i++) { if (edgeDirs[i].dx !== 0) horiz.push(i); else vert.push(i); }
    const solve = (indices, isX) => {
      let missing = indices.filter(idx => sVals[idx] === null);
      if (missing.length === 1) {
        let targetIdx = missing[0], sum = 0;
        indices.forEach(idx => { if (idx !== targetIdx && sVals[idx] !== null) sum += (isX ? edgeDirs[idx].dx : edgeDirs[idx].dy) * sVals[idx]; });
        inputs[targetIdx].value = Math.abs(sum); inputs[targetIdx].classList.add("auto-filled");
      }
    };
    solve(horiz, true); solve(vert, false);
  }

  overlay.onclick = (e) => {
    const rect = overlay.getBoundingClientRect();
    const scaleX = overlay.width/rect.width, scaleY = overlay.height/rect.height;
    const x = (e.clientX - rect.left)*scaleX, y = (e.clientY - rect.top)*scaleY;
    for (let zone of numberHitZones) { if (Math.hypot(x-zone.x, y-zone.y) < zone.radius) { let t = document.getElementById(zone.id); if(t){ t.scrollIntoView({behavior:'smooth',block:'center'}); t.focus(); } break; } }
  };

  function drawGrid(can, pts, sVals, tW, tH) {
    let xs = pts.map(p=>p.x), ys = pts.map(p=>p.y);
    let minX = Math.min(...xs), maxX = Math.max(...xs), minY = Math.min(...ys), maxY = Math.max(...ys);
    let spanX = maxX-minX||1, spanY = maxY-minY||1;
    can.width = 1000; can.height = 1000 * (spanY/spanX);
    let ctx = can.getContext("2d"), pad = 80, scale = Math.min((1000-2*pad)/spanX, (can.height-2*pad)/spanY);
    let tx = (x)=>pad+(x-minX)*scale, ty = (y)=>pad+(y-minY)*scale;
    ctx.save(); ctx.beginPath(); ctx.moveTo(tx(pts[0].x), ty(pts[0].y));
    for(let i=1; i<pts.length; i++) ctx.lineTo(tx(pts[i].x), ty(pts[i].y));
    ctx.closePath(); ctx.clip();
    ctx.strokeStyle = "#94a3b8"; ctx.lineWidth = 2;
    let count = 0;
    for(let x=minX-tW; x<maxX+tW; x+=tW) for(let y=minY-tH; y<maxY+tH; y+=tH) {
      ctx.strokeRect(tx(x), ty(y), tW*scale, tH*scale);
      let midX = x+tW/2, midY = y+tH/2, inside = false;
      for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) { if (((pts[i].y > midY) !== (pts[j].y > midY)) && (midX < (pts[j].x-pts[i].x)*(midY-pts[i].y)/(pts[j].y-pts[i].y)+pts[i].x)) inside = !inside; }
      if(inside) count++;
    }
    ctx.restore();
    ctx.lineWidth = 12; ctx.font = "bold 30px Arial"; ctx.textAlign = "center";
    for(let i=0; i<sVals.length; i++){
      let p1=pts[i], p2=pts[i+1], color=edgeColors[i % edgeColors.length];
      ctx.strokeStyle = color; ctx.beginPath(); ctx.moveTo(tx(p1.x), ty(p1.y)); ctx.lineTo(tx(p2.x), ty(p2.y)); ctx.stroke();
      let angle = Math.atan2(ty(p2.y)-ty(p1.y), tx(p2.x)-tx(p1.x)); if(angle > Math.PI/2 || angle < -Math.PI/2) angle += Math.PI;
      ctx.save(); ctx.translate(tx((p1.x+p2.x)/2), ty((p1.y+p2.y)/2)); ctx.rotate(angle); ctx.fillStyle = color; ctx.fillText(sVals[i], 0, -35); ctx.restore();
    }
    return count;
  }

  function processFloorResults() {
    let sVals = [...document.getElementsByClassName("side-val")].map(i=>Number(i.value));
    if(sVals.some(v=>v<=0)) return alert("××œ× ××ª ×›×œ ×”××™×“×•×ª!");
    let pts = [{x:0,y:0}], curX=0, curY=0;
    for(let i=0; i<edgeDirs.length; i++){ curX += edgeDirs[i].dx * sVals[i]; curY += edgeDirs[i].dy * sVals[i]; pts.push({x: curX, y: curY}); }
    
    let area = 0; for(let i=0; i<pts.length-1; i++) area += (pts[i].x*pts[i+1].y)-(pts[i+1].x*pts[i].y);
    let areaM2 = Math.abs(area)/20000;

    projectData.tempFloor = { pts, sVals, areaM2 };
    
    let cA = drawGrid(document.getElementById("floorResA"), pts, sVals, settings.fW, settings.fH);
    let cB = drawGrid(document.getElementById("floorResB"), pts, sVals, settings.fH, settings.fW);
    
    document.getElementById("floorReportA").textContent = `×›××•×ª: ${cA} ×™×—' | ${areaM2.toFixed(2)} ×"×¨`;
    document.getElementById("floorReportB").textContent = `×›××•×ª: ${cB} ×™×—' | ${areaM2.toFixed(2)} ×"×¨`;
    document.getElementById("floorResultCard").classList.remove("hidden");
    document.getElementById("floorResultCard").scrollIntoView({behavior: "smooth"});
  }

  function selectFloorOrientation(opt) {
    projectData.floorOrientation = opt;
    projectData.floor = {
        pts: projectData.tempFloor.pts,
        sVals: projectData.tempFloor.sVals,
        area: projectData.tempFloor.areaM2,
        tW: opt === 'A' ? settings.fW : settings.fH,
        tH: opt === 'A' ? settings.fH : settings.fW
    };

    if(settings.h > 0) {
        document.getElementById("floorResultCard").classList.add("hidden");
        // ×”×›× ×ª ×”×©×•×•××” ×œ×§×™×¨×•×ª (×œ×•×§×— ××ª ×¦×œ×¢ 1 ×›×“×•×’××”)
        let sampleWidth = projectData.tempFloor.sVals[0];
        let wallPts = [{x:0,y:0}, {x:sampleWidth,y:0}, {x:sampleWidth,y:settings.h}, {x:0,y:settings.h}, {x:0,y:0}];
        let wallSvals = [sampleWidth, settings.h, sampleWidth, settings.h];
        drawGrid(document.getElementById("wallResA"), wallPts, wallSvals, settings.wW, settings.wH);
        drawGrid(document.getElementById("wallResB"), wallPts, wallSvals, settings.wH, settings.wW);
        document.getElementById("wallLockCard").classList.remove("hidden");
    } else showDashboard();
  }

  function lockWallOrientation(opt) {
    projectData.wallOrientation = opt;
    let tW = opt === 'A' ? settings.wW : settings.wH;
    let tH = opt === 'A' ? settings.wH : settings.wW;

    // ×™×¦×™×¨×ª ×›×œ ×”×§×™×¨×•×ª ××”×¨×¦×¤×”
    projectData.walls = [];
    for(let i=0; i<projectData.floor.sVals.length; i++) {
        let w = projectData.floor.sVals[i];
        let pts = [{x:0,y:0}, {x:w,y:0}, {x:w,y:settings.h}, {x:0,y:settings.h}, {x:0,y:0}];
        let sVals = [w, settings.h, w, settings.h];
        let can = document.createElement('canvas');
        let count = drawGrid(can, pts, sVals, tW, tH);
        projectData.walls.push({ pts, sVals, area: (w * settings.h)/10000, count, tW, tH, edgeNum: i+1 });
    }
    showDashboard();
  }

  function showDashboard() {
    projectData.settings = settings;
    localStorage.setItem('smartProject', JSON.stringify(projectData));
    document.getElementById('measurementSection').classList.add('hidden');
    document.getElementById('finalDashboard').classList.remove('hidden');
    
    let sum = document.getElementById('summaryBox');
    let detail = document.getElementById('itemsDetail');
    detail.innerHTML = "";

    let totalFloorM2 = projectData.floor.area;
    let totalFloorTiles = projectData.floor.count || 0; // ×™×—×•×©×‘ ××—×“×© ×œ××˜×”
    let totalWallM2 = 0, totalWallTiles = 0;

    // ×¨×¦×¤×”
    let fCan = document.createElement('canvas');
    totalFloorTiles = drawGrid(fCan, projectData.floor.pts, projectData.floor.sVals, projectData.floor.tW, projectData.floor.tH);
    detail.innerHTML += `<div class="card"><h3>×¨×¦×¤×” (${projectData.floor.tW}x${projectData.floor.tH})</h3><img src="${fCan.toDataURL()}" style="width:100%"><p>×©×˜×—: ${totalFloorM2.toFixed(2)} ×"×¨ | ××¨×™×—×™×: ${totalFloorTiles}</p></div>`;

    // ×§×™×¨×•×ª
    projectData.walls.forEach(w => {
        totalWallM2 += w.area; totalWallTiles += w.count;
        let wCan = document.createElement('canvas');
        drawGrid(wCan, w.pts, w.sVals, w.tW, w.tH);
        detail.innerHTML += `<div class="card" style="border-right: 5px solid ${edgeColors[(w.edgeNum-1)%8]}"><h3>×§×™×¨ ×¦×œ×¢ #${w.edgeNum} (${w.tW}x${w.tH})</h3><img src="${wCan.toDataURL()}" style="width:100%"><p>×©×˜×—: ${w.area.toFixed(2)} ×"×¨ | ××¨×™×—×™×: ${w.count}</p></div>`;
    });

    sum.innerHTML = `<b>×¡×™×›×•× ×¨×™×¦×•×£:</b> ${totalFloorM2.toFixed(2)} ×"×¨ (${totalFloorTiles} ×™×—') <br> <b>×¡×™×›×•× ×—×™×¤×•×™ ×§×™×¨×•×ª:</b> ${totalWallM2.toFixed(2)} ×"×¨ (${totalWallTiles} ×™×—')`;
  }

  function clearAll() { if(confirm("×œ××—×•×§ ×”×›×œ?")) { localStorage.removeItem('smartProject'); location.reload(); } }

  async function sharePDF() {
    const el = document.getElementById('pdfContent');
    const canvas = await html2canvas(el, { scale: 2 });
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p', 'mm', [210, (canvas.height * 210) / canvas.width]);
    pdf.addImage(imgData, 'PNG', 0, 0, 210, (canvas.height * 210) / canvas.width);
    const file = new File([pdf.output('blob')], 'Report.pdf', { type: 'application/pdf' });
    if(navigator.share) await navigator.share({ files: [file], title: '×“×•×— ××“×™×“×•×ª' }); else pdf.save("Project.pdf");
  }

  // Pinch Zoom
  [document.getElementById("floorResA"), document.getElementById("floorResB")].forEach(can => {
    let s=1, d0=0;
    can.parentElement.addEventListener('touchstart', e => { if(e.touches.length==2) d0=Math.hypot(e.touches[0].pageX-e.touches[1].pageX, e.touches[0].pageY-e.touches[1].pageY); });
    can.parentElement.addEventListener('touchmove', e => { if(e.touches.length==2){ e.preventDefault(); let d=Math.hypot(e.touches[0].pageX-e.touches[1].pageX, e.touches[0].pageY-e.touches[1].pageY); s=Math.min(Math.max(0.5, s*(d/d0)), 5); can.style.transform=`scale(${s})`; d0=d; } }, {passive:false});
  });
</script>
</body>
</html>
27