<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>住专拽  - 转 </title>
    <script src="https://docs.opencv.org/4.7.0/opencv.js" async></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        * { box-sizing: border-box; }
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; color: white; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        .app { display: flex; flex-direction: column; height: 100dvh; }
        
        .viewer { flex: 1; position: relative; display: flex; align-items: center; justify-content: center; background: #000; overflow: hidden; }
        video, canvas { width: 100%; height: 100%; object-fit: contain; }
        #canvasOutput { display: none; }

        .footer { background: #111; padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 15px; border-top-left-radius: 20px; border-top-right-radius: 20px; }
        
        #msg { font-size: 14px; color: #ccc; }

        /* 驻转专 爪 */
        .snap-btn-container { display: flex; justify-content: center; width: 100%; }
        .snap-btn { width: 70px; height: 70px; background: white; border-radius: 50%; border: 4px solid rgba(255,255,255,0.3); cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .snap-btn:active { transform: scale(0.95); }
        .snap-inner { width: 54px; height: 54px; border-radius: 50%; border: 2px solid #000; }

        /* 拽专 专 爪 */
        .result-controls { display: none; flex-direction: column; gap: 15px; width: 100%; max-width: 400px; }
        
        .filter-toggle { display: flex; align-items: center; justify-content: space-between; background: #222; padding: 10px 15px; border-radius: 10px; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2ecc71; }
        input:checked + .slider:before { transform: translateX(26px); }

        .btn-group { display: flex; gap: 10px; }
        .btn { flex: 1; padding: 12px; border-radius: 10px; border: none; font-weight: 600; font-size: 15px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .btn-send { background: #2ecc71; color: white; }
        .btn-cancel { background: #333; color: white; }

        #loader { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 99; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .spinner { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-top-color: white; border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <p style="margin-top: 15px;"> 转 注专转...</p>
</div>

<div class="app">
    <div class="viewer">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div class="footer">
        <div id="msg">拽 转 祝 专 抓 注 爪</div>
        
        <div id="ui-capture" class="snap-btn-container">
            <div class="snap-btn" onclick="processDoc()">
                <div class="snap-inner"></div>
            </div>
        </div>

        <div id="ui-result" class="result-controls">
            <div class="filter-toggle">
                <span>住专拽 砖专- 拽</span>
                <label class="switch">
                    <input type="checkbox" id="bwToggle" checked onchange="applyFilter()">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="btn-group">
                <button class="btn btn-cancel" onclick="reset()"> 爪 砖</button>
                <button class="btn btn-send" onclick="sendToWhatsApp()"> 砖 PDF</button>
            </div>
        </div>
    </div>
</div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvasOutput');
    const msg = document.getElementById('msg');
    const bwToggle = document.getElementById('bwToggle');
    let isReady = false;
    let originalCapture = null; // 砖专转 转 拽专转 (转)

    window.onload = () => {
        let timer = setInterval(() => {
            if (typeof cv !== 'undefined' && cv.Mat) {
                clearInterval(timer);
                isReady = true;
                document.getElementById('loader').style.display = 'none';
                initCamera();
            }
        }, 200);
    };

    async function initCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "environment", width: { ideal: 1920 }, height: { ideal: 1080 } } 
            });
            video.srcObject = stream;
        } catch (e) { alert("砖 爪 转 HTTPS"); }
    }

    function processDoc() {
        if (!isReady) return;
        msg.innerText = "注 转...";
        
        let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        let cap = new cv.VideoCapture(video);
        cap.read(src);

        // 1. 爪转 拽专 祝
        let docContour = findDocumentContour(src);
        
        // 2. 爪注 转 砖专
        if (docContour) {
            msg.innerText = "祝 ! 爪注 转...";
            originalCapture = warpDocument(src, docContour);
            docContour.delete();
        } else {
            msg.innerText = "  祝 专专. 爪 转 .";
            originalCapture = src.clone();
        }
        src.delete();

        // 3. 爪转 转爪 转 驻专 专砖
        applyFilter();
        
        video.style.display = 'none';
        canvas.style.display = 'block';
        document.getElementById('ui-capture').style.display = 'none';
        document.getElementById('ui-result').style.display = 'flex';
    }

    // 驻拽爪 爪转 专注  转专 转
    function findDocumentContour(src) {
        let gray = new cv.Mat();
        let blurred = new cv.Mat();
        let edged = new cv.Mat();
        
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        cv.Canny(blurred, edged, 75, 200);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let maxArea = 0;
        let bestCnt = null;
        const minArea = (src.rows * src.cols) * 0.1; // 祝  转 驻转 10% 转

        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            
            if (area > minArea) {
                let peri = cv.arcLength(cnt, true);
                let approx = new cv.Mat();
                cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                
                if (approx.rows === 4 && area > maxArea) {
                    maxArea = area;
                    if (bestCnt) bestCnt.delete();
                    bestCnt = approx.clone();
                }
                approx.delete();
            }
        }
        gray.delete(); blurred.delete(); edged.delete(); contours.delete(); hierarchy.delete();
        return bestCnt;
    }

    // 驻拽爪转 注专 住专 拽转 驻
    function orderPoints(pts) {
        let points = [];
        for (let i = 0; i < 4; i++) {
            points.push({ x: pts.data32S[i * 2], y: pts.data32S[i * 2 + 1] });
        }
        points.sort((a, b) => (a.x + a.y) - (b.x + b.y));
        let tl = points[0]; let br = points[3];
        let others = [points[1], points[2]].sort((a, b) => (a.y - a.x) - (b.y - b.x));
        let tr = others[0]; let bl = others[1];
        return [tl, tr, br, bl];
    }

    // 驻拽爪 爪注 专住驻专爪转 驻专住驻拽 (转 砖专 驻注)
    function warpDocument(src, cnt) {
        let orderedPts = orderPoints(cnt);
        
        let widthA = Math.hypot(orderedPts[2].x - orderedPts[3].x, orderedPts[2].y - orderedPts[3].y);
        let widthB = Math.hypot(orderedPts[1].x - orderedPts[0].x, orderedPts[1].y - orderedPts[0].y);
        let maxWidth = Math.max(widthA, widthB);

        let heightA = Math.hypot(orderedPts[1].x - orderedPts[2].x, orderedPts[1].y - orderedPts[2].y);
        let heightB = Math.hypot(orderedPts[0].x - orderedPts[3].x, orderedPts[0].y - orderedPts[3].y);
        let maxHeight = Math.max(heightA, heightB);

        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [orderedPts[0].x, orderedPts[0].y, orderedPts[1].x, orderedPts[1].y, orderedPts[2].x, orderedPts[2].y, orderedPts[3].x, orderedPts[3].y]);
        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, maxWidth - 1, 0, maxWidth - 1, maxHeight - 1, 0, maxHeight - 1]);

        let M = cv.getPerspectiveTransform(srcTri, dstTri);
        let warped = new cv.Mat();
        cv.warpPerspective(src, warped, M, new cv.Size(maxWidth, maxHeight));

        srcTri.delete(); dstTri.delete(); M.delete();
        return warped;
    }

    // 转 驻专 (砖专-  爪注) 注 转 转
    function applyFilter() {
        if (!originalCapture) return;
        let dst = new cv.Mat();
        if (bwToggle.checked) {
            cv.cvtColor(originalCapture, dst, cv.COLOR_RGBA2GRAY);
            cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 12);
        } else {
            originalCapture.copyTo(dst);
        }
        cv.imshow('canvasOutput', dst);
        dst.delete();
    }

    async function sendToWhatsApp() {
        msg.innerText = " PDF...";
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        const imgData = canvas.toDataURL('image/jpeg', 0.85);
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
        
        const blob = pdf.output('blob');
        const file = new File([blob], "scanned_document.pdf", { type: "application/pdf" });

        if (navigator.share) {
            try {
                await navigator.share({ files: [file], title: '住 住专拽 砖' });
            } catch (e) { msg.innerText = "砖转祝 "; }
        } else {
            pdf.save("scanned_document.pdf");
            msg.innerText = "拽抓 专 砖专";
        }
    }

    function reset() {
        if (originalCapture) originalCapture.delete();
        originalCapture = null;
        video.style.display = 'block';
        canvas.style.display = 'none';
        document.getElementById('ui-capture').style.display = 'flex';
        document.getElementById('ui-result').style.display = 'none';
        msg.innerText = "拽 转 祝 专 抓 注 爪";
    }
</script>
</body>
</html>
charles.s
