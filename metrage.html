<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>×¦×™×œ×•× ×©×¨×˜×•×˜ â†’ ×–×™×”×•×™ ×¦×œ×¢×•×ª â†’ ×”×–× ×ª ×¡×´×</title>

<!-- OpenCV -->
<script>
  // × ×©×ª××© ×‘×“×’×œ ××•×›×Ÿ ×œ-OpenCV
  window.__cvReady = false;
</script>
<script async src="https://docs.opencv.org/4.7.0/opencv.js" onload="__onCvScriptLoaded()"></script>

<style>
  :root{--bg:#f4f6f9;--card:#fff;--text:#111827;--muted:#6b7280;--primary:#2563eb;--danger:#dc2626;--line:#e5e7eb;}
  *{box-sizing:border-box}
  body{margin:0;padding:16px;font-family:system-ui,Arial;background:var(--bg);color:var(--text)}
  .wrap{max-width:980px;margin:0 auto}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;margin-bottom:14px;box-shadow:0 10px 25px rgba(0,0,0,.08)}
  h2{margin:0 0 10px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{
    width:100%; padding:14px 16px; border:0; border-radius:12px;
    background:var(--primary); color:#fff; font-size:18px; cursor:pointer;
  }
  .btn:disabled{opacity:.5; cursor:not-allowed}
  .btn.secondary{background:#111827}
  .btn.danger{background:var(--danger)}
  .note{color:var(--muted);font-size:14px;margin-top:8px;line-height:1.45}
  video,canvas{width:100%;border-radius:12px;border:1px solid var(--line);background:#fff}
  .hidden{display:none}
  input{
    width:100%; padding:12px; border:1px solid var(--line); border-radius:12px;
    font-size:16px; outline:none; margin-bottom:10px;
  }
  input:focus{border-color:var(--primary); box-shadow:0 0 0 3px rgba(37,99,235,.12)}
  .status{
    padding:10px 12px; border-radius:12px; border:1px solid var(--line);
    background:#fff; color:#111827; font-size:14px;
  }
  .status.good{border-color:rgba(34,197,94,.35)}
  .status.bad{border-color:rgba(220,38,38,.35)}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
</style>
</head>

<body>
<div class="wrap">

  <div class="card">
    <h2>1ï¸âƒ£ ×¦×™×œ×•× ×©×¨×˜×•×˜ (××¦×œ××” ××—×•×¨×™×ª)</h2>

    <div id="statusBox" class="status">×˜×•×¢×Ÿâ€¦</div>
    <div class="note">
      ×”×›×¤×ª×•×¨ â€œ×¦×œ×â€ ×™×•×¤×¢×œ ×¨×§ ××—×¨×™ ×©Ö¾<b>×”××¦×œ××” ××•×›× ×”</b> ×•×’× <b>OpenCV ××•×›×Ÿ</b>.
    </div>

    <div style="margin-top:12px">
      <video id="video" autoplay playsinline></video>
      <canvas id="photo" class="hidden"></canvas>
    </div>

    <div class="row" style="margin-top:12px">
      <button id="btnShot" class="btn" type="button" disabled>ğŸ“¸ ×¦×œ×</button>
      <button id="btnRestart" class="btn secondary" type="button">ğŸ”„ ××ª×—×œ ××¦×œ××”</button>
    </div>

    <div class="note">
      ×× ×”×“×¤×“×¤×Ÿ ××‘×§×© ×”×¨×©××” â€“ ×ª××©×¨. ×—×™×™×‘ ×œ×”×™×•×ª URL ×©×œ <span class="mono">https://</span> (GitHub Pages).
    </div>
  </div>

  <div class="card hidden" id="previewCard">
    <h2>×ª××•× ×” ×©× ×œ×›×“×”</h2>
    <canvas id="preview"></canvas>
    <div class="note">×× ××ª×” ×¨×•××” ×›××Ÿ ××ª ×”×©×¨×˜×•×˜ â€“ ×”×¦×™×œ×•× ×”×¦×œ×™×—, ×•×××©×™×›×™× ×œ×–×™×”×•×™.</div>
  </div>

  <div class="card hidden" id="edgesCard">
    <h2>2ï¸âƒ£ ×–×™×”×•×™ ×§×•×•×™× / ×¦×œ×¢×•×ª</h2>
    <canvas id="edges"></canvas>
    <div id="edgesInfo" class="note"></div>
  </div>

  <div class="card hidden" id="inputsCard">
    <h2>3ï¸âƒ£ ×”×–×Ÿ ××™×“×•×ª (×‘×¡×´×)</h2>
    <div id="inputs"></div>
    <button id="btnBuild" class="btn" type="button">ğŸ“ ×‘× ×” ×©×¨×˜×•×˜ ×œ×¤×™ ×”××™×“×•×ª</button>
    <div class="note">
      ××ª×” ××–×™×Ÿ <b>×‘×¡×´× ×‘×œ×‘×“</b>. ×”×¤×¨×•×¤×•×¨×¦×™×•×ª ×‘×©×¨×˜×•×˜ ×™×”×™×• <b>×¨×§ ×œ×¤×™ ×”××¡×¤×¨×™×</b> (500 ×ª××™×“ ×™×™×¨××” ××¨×•×š ×Ö¾300).
    </div>
  </div>

  <div class="card hidden" id="resultCard">
    <h2>4ï¸âƒ£ ×©×¨×˜×•×˜ ×¡×•×¤×™</h2>
    <canvas id="result"></canvas>
    <div id="perimeter" class="note"></div>
  </div>

</div>

<script>
  const video = document.getElementById("video");
  const photo = document.getElementById("photo");
  const preview = document.getElementById("preview");
  const edgesCanvas = document.getElementById("edges");
  const resultCanvas = document.getElementById("result");

  const previewCard = document.getElementById("previewCard");
  const edgesCard = document.getElementById("edgesCard");
  const inputsCard = document.getElementById("inputsCard");
  const resultCard = document.getElementById("resultCard");

  const statusBox = document.getElementById("statusBox");
  const btnShot = document.getElementById("btnShot");
  const btnRestart = document.getElementById("btnRestart");
  const btnBuild = document.getElementById("btnBuild");

  let stream = null;
  let videoReady = false;
  let cvReady = false;

  let detectedCorners = []; // × ×§×•×“×•×ª ×”×¤×•×œ×™×’×•×Ÿ
  let detectedSideCount = 0;

  function setStatus(msg, type){
    statusBox.textContent = msg;
    statusBox.classList.remove("good","bad");
    if(type) statusBox.classList.add(type);
  }

  function updateShotEnabled(){
    btnShot.disabled = !(videoReady && cvReady);
  }

  // × ×§×¨× ×›×©×”×¡×§×¨×™×¤×˜ opencv.js × ×˜×¢×Ÿ
  function __onCvScriptLoaded(){
    // cv ×¢×¦××• ××¡×™×™× ××ª×—×•×œ async
    const wait = setInterval(() => {
      if (window.cv && cv.Mat) {
        // onRuntimeInitialized ×œ×¤×¢××™× ×§×™×™×, ×œ×¤×¢××™× ×›×‘×¨ ×¢×‘×¨
        if (cv.onRuntimeInitialized) {
          cv.onRuntimeInitialized = () => {
            cvReady = true;
            setStatus("OpenCV ××•×›×Ÿ âœ…", "good");
            updateShotEnabled();
          };
          // ×× ×›×‘×¨ ××•×›×Ÿ â€” × ×¡××Ÿ ××™×“
          try{
            // ×‘×“×™×§×” ×¢×“×™× ×”: ×™×¦×™×¨×ª Mat
            const t = new cv.Mat();
            t.delete();
            cvReady = true;
            setStatus("OpenCV ××•×›×Ÿ âœ…", "good");
            updateShotEnabled();
            clearInterval(wait);
          }catch(e){
            // × ×—×›×” ×œ-onRuntimeInitialized
          }
        } else {
          // ×× ××™×Ÿ onRuntimeInitialized, × ×‘×“×•×§ ×™×¦×™×¨×ª Mat
          try{
            const t = new cv.Mat();
            t.delete();
            cvReady = true;
            setStatus("OpenCV ××•×›×Ÿ âœ…", "good");
            updateShotEnabled();
            clearInterval(wait);
          }catch(e){}
        }
      }
    }, 80);
  }

  async function startCamera(){
    try{
      videoReady = false;
      updateShotEnabled();
      setStatus("×¤×•×ª×— ××¦×œ××” ××—×•×¨×™×ªâ€¦", null);

      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }

      // × ×™×¡×™×•×Ÿ 1: exact environment (× ×¢×™×œ×” ×—×–×§×”)
      try{
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { exact: "environment" },
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: false
        });
      } catch (e1) {
        // × ×™×¡×™×•×Ÿ 2: environment ×‘×œ×™ exact (×ª××™××•×ª ×˜×•×‘×” ×™×•×ª×¨)
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false
        });
      }

      video.srcObject = stream;

      await new Promise((resolve) => {
        video.onloadedmetadata = () => resolve();
      });

      // ×œ×¤×¢××™× ×¦×¨×™×š play ××¤×•×¨×© ×‘×× ×“×¨×•××™×“
      await video.play();

      videoReady = true;
      setStatus("××¦×œ××” ××•×›× ×” âœ… (××—×•×¨×™×ª)", "good");
      updateShotEnabled();

    } catch (err) {
      setStatus("×©×’×™××” ×‘×¤×ª×™×—×ª ××¦×œ××”: " + (err && err.message ? err.message : err), "bad");
      btnShot.disabled = true;
    }
  }

  function captureToCanvas(){
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    if (!vw || !vh){
      throw new Error("×”×•×•×™×“××• ×¢×“×™×™×Ÿ ×œ× ××•×›×Ÿ (videoWidth=0). × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×©× ×™×™×”.");
    }

    photo.width = vw;
    photo.height = vh;
    const ctx = photo.getContext("2d", { willReadFrequently: true });
    ctx.drawImage(video, 0, 0, vw, vh);

    // preview
    const pr = preview.getContext("2d");
    preview.width = vw;
    preview.height = vh;
    pr.drawImage(photo, 0, 0);

    previewCard.classList.remove("hidden");
  }

  function detectPolygonFromPhoto(){
    if (!cvReady) throw new Error("OpenCV ×¢×“×™×™×Ÿ ×œ× ××•×›×Ÿ.");

    // ×§×¨×™××” ××”-canvas
    let src = cv.imread(photo);
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let edges = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
    cv.Canny(blur, edges, 60, 180);

    // ×¡×’×™×¨×” ××•×¨×¤×•×œ×•×’×™×ª ×§×œ×” ×›×“×™ ×œ×—×‘×¨ ×§×•×•×™×
    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
    cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    if (contours.size() === 0){
      cleanup();
      throw new Error("×œ× × ××¦××• ×§×•×•×™×/×§×•× ×˜×•×¨×™×. × ×¡×” ×¦×™×œ×•× ×‘×¨×•×¨ ×™×•×ª×¨ (× ×™×’×•×“×™×•×ª ×’×‘×•×”×”, ×“×£ ×‘×”×™×¨).");
    }

    // ×‘×•×—×¨×™× ××ª ×”×§×•× ×˜×•×¨ ×”×’×“×•×œ ×‘×™×•×ª×¨
    let biggest = null;
    let maxArea = 0;
    for (let i=0; i<contours.size(); i++){
      let cnt = contours.get(i);
      let area = cv.contourArea(cnt);
      if (area > maxArea){
        maxArea = area;
        biggest = cnt;
      }
    }

    if (!biggest || maxArea < 5000){
      cleanup();
      throw new Error("×–×•×”×” ×§×•× ×˜×•×¨ ×§×˜×Ÿ ××“×™. ×ª×§×¨×‘ ××¦×œ××” ××• ×ª×¢×©×” ×§×•×•×™× ×¢×‘×™× ×™×•×ª×¨.");
    }

    // ×§×™×¨×•×‘ ×œ×¤×•×œ×™×’×•×Ÿ (××¡×¤×¨ ×¤×™× ×•×ª)
    let approx = new cv.Mat();
    let peri = cv.arcLength(biggest, true);
    // epsilon ×™×—×¡×™×ª ×œ×”×™×§×£ â€“ ×™×¦×™×‘ ×™×•×ª×¨ ××¦×™×¨×•×£ ××¡×¤×¨ ×§×‘×•×¢
    cv.approxPolyDP(biggest, approx, 0.02 * peri, true);

    // × ×§×•×“×•×ª
    detectedCorners = [];
    for (let i=0; i<approx.rows; i++){
      detectedCorners.push({
        x: approx.intPtr(i,0)[0],
        y: approx.intPtr(i,0)[1]
      });
    }

    detectedSideCount = detectedCorners.length;

    // ×”×¦×’×” ×©×œ edges
    cv.imshow(edgesCanvas, edges);
    edgesCard.classList.remove("hidden");
    document.getElementById("edgesInfo").textContent = `×–×•×”×• ${detectedSideCount} ×¦×œ×¢×•×ª. ×¢×›×©×™×• ×”×–×Ÿ ${detectedSideCount} ××™×“×•×ª ×‘×¡×´×.`;

    // Inputs
    buildInputs(detectedSideCount);

    cleanup();

    function cleanup(){
      src.delete(); gray.delete(); blur.delete(); edges.delete();
      kernel.delete(); contours.delete(); hierarchy.delete(); approx.delete();
    }
  }

  function buildInputs(n){
    const box = document.getElementById("inputs");
    box.innerHTML = "";
    for (let i=0; i<n; i++){
      const input = document.createElement("input");
      input.type = "number";
      input.inputMode = "numeric";
      input.min = "0";
      input.step = "1";
      input.placeholder = `××•×¨×š ×¦×œ×¢ ${i+1} ×‘×¡×´×`;
      input.dataset.idx = i;
      box.appendChild(input);
    }
    inputsCard.classList.remove("hidden");
  }

  function buildFinalDrawing(){
    const values = [...document.querySelectorAll("#inputs input")].map(i => Number(i.value));

    if (values.length !== detectedSideCount){
      alert("××¡×¤×¨ ××™×“×•×ª ×œ× ×ª×•××.");
      return;
    }
    if (values.some(v => !Number.isFinite(v) || v <= 0)){
      alert("×ª×›× ×™×¡ ××™×“×•×ª ×ª×§×™× ×•×ª ×‘×¡×´× ×œ×›×œ ×”×¦×œ×¢×•×ª.");
      return;
    }

    // --- ×¦×™×•×¨: ××©×ª××©×™× ×‘×›×™×•×•× ×™× ××ª×•×š ×”×¤×•×œ×™×’×•×Ÿ ×©×–×•×”×” (×”×¦×™×•×¨ ×”××§×•×¨×™),
    // ××‘×œ ×”××•×¨×›×™× × ×§×‘×¢×™× ×œ×¤×™ ×”××¡×¤×¨×™× ×©×œ×š (×¤×¨×•×¤×•×¨×¦×™×•×ª × ×›×•× ×•×ª).
    // × ×‘× ×” ×¨×©×™××ª ×›×™×•×•× ×™× (×•×§×˜×•×¨×™× ×× ×•×¨××œ×™×) ×œ×¤×™ ×¡×“×¨ ×”×¤×™× ×•×ª.
    const dirs = [];
    for (let i=0; i<detectedCorners.length; i++){
      const a = detectedCorners[i];
      const b = detectedCorners[(i+1) % detectedCorners.length];
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      const mag = Math.hypot(dx, dy) || 1;
      dx /= mag; dy /= mag;
      dirs.push({dx, dy});
    }

    // ×¡×§×œ×ª ×¦×™×•×¨ (×¤×™×§×¡×œ×™×) â€“ ×œ×¤×™ ×”×¦×œ×¢ ×”××¨×•×›×” ×‘×™×•×ª×¨
    const W = 900, H = 520;
    resultCanvas.width = W;
    resultCanvas.height = H;
    const ctx = resultCanvas.getContext("2d");
    ctx.clearRect(0,0,W,H);

    const maxLen = Math.max(...values);
    const scale = 380 / maxLen; // × ×•×ª×Ÿ ×’×•×“×œ ×˜×•×‘
    let x = W/2, y = H/2;

    // ×§×•×“× × ×¦×™×™×¨ ×›×“×™ ×œ×§×‘×œ bounding box ×•×œ××¨×›×– ×˜×•×‘:
    const pts = [{x, y}];
    for (let i=0; i<values.length; i++){
      x += dirs[i].dx * values[i] * scale;
      y += dirs[i].dy * values[i] * scale;
      pts.push({x, y});
    }

    // bounding
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for (const p of pts){ minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x); minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y); }
    const cx = (minX+maxX)/2;
    const cy = (minY+maxY)/2;
    const shiftX = W/2 - cx;
    const shiftY = H/2 - cy;

    // ×¦×™×•×¨ ×¡×•×¤×™
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#2563eb";
    ctx.fillStyle = "rgba(37,99,235,0.06)";
    ctx.beginPath();
    ctx.moveTo(pts[0].x + shiftX, pts[0].y + shiftY);
    for (let i=1; i<pts.length; i++){
      ctx.lineTo(pts[i].x + shiftX, pts[i].y + shiftY);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // ×›×ª×™×‘×ª ××™×“×•×ª ×¢×œ ×›×œ ×¦×œ×¢ (×¤×©×•×˜)
    ctx.fillStyle = "#111827";
    ctx.font = "14px system-ui";
    for (let i=0; i<values.length; i++){
      const p1 = pts[i], p2 = pts[i+1];
      const mx = (p1.x+p2.x)/2 + shiftX;
      const my = (p1.y+p2.y)/2 + shiftY;
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText(values[i] + " ×¡×´×", mx, my - 6);
    }

    // ×”×™×§×£
    const per = values.reduce((a,b)=>a+b,0);
    document.getElementById("perimeter").textContent = `×”×™×§×£: ${per} ×¡×´×`;

    resultCard.classList.remove("hidden");
  }

  // Bind buttons
  btnShot.addEventListener("click", () => {
    try{
      setStatus("××¦×œ× ×•×× ×ª×—â€¦", null);
      captureToCanvas();
      detectPolygonFromPhoto();
      setStatus("×–×™×”×•×™ ×”×•×©×œ× âœ…", "good");
    } catch (e){
      setStatus("×©×’×™××”: " + (e && e.message ? e.message : e), "bad");
    }
  });

  btnRestart.addEventListener("click", () => {
    // ××™×¤×•×¡ ×ª×¦×•×’×•×ª
    previewCard.classList.add("hidden");
    edgesCard.classList.add("hidden");
    inputsCard.classList.add("hidden");
    resultCard.classList.add("hidden");
    document.getElementById("inputs").innerHTML = "";
    detectedCorners = [];
    detectedSideCount = 0;
    startCamera();
  });

  btnBuild.addEventListener("click", () => {
    try{
      buildFinalDrawing();
    } catch (e){
      alert("×©×’×™××” ×‘×‘× ×™×™×ª ×©×¨×˜×•×˜: " + (e && e.message ? e.message : e));
    }
  });

  // Start
  setStatus("×××ª×—×œâ€¦", null);
  startCamera();
</script>

</body>
</html>