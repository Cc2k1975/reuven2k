<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>××•× ×” ×™×—×™×“×•×ª ××ª××•× ×” (×œ×œ× API)</title>
  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Arial;background:#0f1115;color:#fff}
    header{padding:14px 14px 10px;border-bottom:1px solid #222}
    h1{margin:0;font-size:18px}
    .wrap{padding:12px;display:grid;gap:12px}
    .card{background:#151923;border:1px solid #242a3a;border-radius:16px;padding:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{border:0;border-radius:12px;padding:12px 14px;font-size:15px;font-weight:700;background:#2b6cff;color:#fff}
    button:disabled{opacity:.5}
    .btn2{background:#2a2f3f}
    .pill{background:#222a3d;border:1px solid #2e3a5c;border-radius:999px;padding:6px 10px;font-size:13px}
    .grid2{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:900px){.grid2{grid-template-columns:1fr 1fr}}
    canvas,img{max-width:100%;border-radius:12px;border:1px solid #2a2f3f;background:#0b0d12}
    label{font-size:13px;opacity:.9}
    input[type="range"]{width:100%}
    .kv{display:flex;justify-content:space-between;gap:10px;font-size:13px;opacity:.95}
    .small{font-size:12px;opacity:.75;line-height:1.35}
    .warn{color:#ffd27a}
  </style>
</head>
<body>
  <header>
    <h1>××•× ×” ×™×—×™×“×•×ª ××ª××•× ×” (×¦×™×œ×•× ×—×•×¤×©×™, ×œ×œ× API)</h1>
    <div class="small">×¢×•×‘×“ ×‘×“×¤×“×¤×Ÿ. ×”×›×™ ××“×•×™×§ ×›×©××™×Ÿ ×—×¤×™×¤×” ×‘×™×Ÿ ××•×‘×™×™×§×˜×™× + ×¨×§×¢ ××—×™×“. ×‘×¦×™×œ×•× ×—×•×¤×©×™ ×¦×¨×™×š ×œ×¤×¢××™× ×œ×›×•×•×Ÿ ×¡×œ×™×™×“×¨×™×.</div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="row">
        <button id="btnPick" disabled>ğŸ“· ×¦×™×œ×•×/×‘×—×™×¨×ª ×ª××•× ×”</button>
        <button id="btnRun" class="btn2" disabled>â–¶ï¸ ×¡×¤×•×¨ ×¢×›×©×™×•</button>
        <span class="pill">×ª×•×¦××”: <b id="count">â€”</b></span>
        <span class="pill">×¡×˜×˜×•×¡: <b id="status">×˜×•×¢×Ÿ OpenCVâ€¦</b></span>
      </div>
      <div class="small warn" id="hint" style="margin-top:10px;display:none">
        ×× OpenCV ×œ× × ×˜×¢×Ÿ (×‘××™×•×—×“ ×‘×œ×™ ××™× ×˜×¨× ×˜) â€” ×ª×•×¨×™×“ ××ª ×”×§×•×‘×¥ opencv.js ××§×•××™×ª ×•×ª×¢×“×›×Ÿ ××ª ×”×©×•×¨×” ×‘×§×•×“ (××•×¡×‘×¨ ×œ××˜×”).
      </div>

      <input id="file" type="file" accept="image/*" capture="environment" style="display:none" />
    </div>

    <div class="grid2">
      <div class="card">
        <div class="kv"><b>×ª××•× ×” ××§×•×¨×™×ª</b><span class="small">×”×›×™ ×˜×•×‘: ××œ××¢×œ×”, ×‘×œ×™ ×ª×–×•×–×”</span></div>
        <img id="preview" alt="×ª××•× ×”" />
      </div>

      <div class="card">
        <div class="kv"><b>×¤×œ×˜/×¡×™××•×Ÿ ×–×™×”×•×™</b><span class="small">×”××¡×¤×¨×™× ×”× ××•×‘×™×™×§×˜×™× ×©× ×¡×¤×¨×•</span></div>
        <canvas id="out"></canvas>
      </div>
    </div>

    <div class="card">
      <b>×›×™×•×•× ×•×Ÿ ××”×™×¨ (×—×©×•×‘ ×œ×¦×™×œ×•× ×—×•×¤×©×™)</b>
      <div class="small" style="margin-top:6px">×˜×™×¤: ×× ×¡×•×¤×¨ â€œ×™×•×ª×¨ ××“×™â€ â€” ×”×¢×œ×” <b>Min Area</b> ××• ×”×’×“×œ × ×™×§×•×™. ×× â€œ××¤×¡×¤×¡â€ â€” ×”×•×¨×“ ×¡×£/Min Area.</div>

      <div style="margin-top:12px;display:grid;gap:12px">
        <div>
          <div class="kv"><label>Threshold (0â€“255)</label><span class="pill"><span id="vThr">150</span></span></div>
          <input id="thr" type="range" min="0" max="255" value="150" />
        </div>

        <div>
          <div class="kv"><label>Invert (×©×—×•×¨/×œ×‘×Ÿ)</label><span class="pill"><span id="vInv">×›×Ÿ</span></span></div>
          <input id="inv" type="range" min="0" max="1" step="1" value="1" />
        </div>

        <div>
          <div class="kv"><label>Blur (0â€“9)</label><span class="pill"><span id="vBlur">3</span></span></div>
          <input id="blur" type="range" min="0" max="9" step="1" value="3" />
        </div>

        <div>
          <div class="kv"><label>Clean (Morph, 0â€“15)</label><span class="pill"><span id="vMorph">5</span></span></div>
          <input id="morph" type="range" min="0" max="15" step="1" value="5" />
        </div>

        <div>
          <div class="kv"><label>Min Area (×¡×™× ×•×Ÿ ××•×‘×™×™×§×˜×™× ×§×˜× ×™×)</label><span class="pill"><span id="vMinA">600</span></span></div>
          <input id="minA" type="range" min="0" max="20000" step="50" value="600" />
        </div>

        <div>
          <div class="kv"><label>Max Area (0=×œ×œ× ××’×‘×œ×”)</label><span class="pill"><span id="vMaxA">0</span></span></div>
          <input id="maxA" type="range" min="0" max="300000" step="500" value="0" />
        </div>
      </div>

      <div class="small" style="margin-top:12px">
        <b>×œ×œ× ××™× ×˜×¨× ×˜?</b> ×”×•×¨×“ opencv.js ×œ×§×•×‘×¥ ××§×•××™ (×œ××©×œ ×œ×ª×™×§×™×™×” ×œ×™×“ ×”-HTML) ×•×©× ×” ××ª ×ª×’×™×ª ×”×¡×§×¨×™×¤×˜ ×œ××˜×” ×œÖ¾
        <code style="color:#fff;background:#0b0d12;padding:2px 6px;border-radius:8px;border:1px solid #222">src="./opencv.js"</code>
      </div>
    </div>
  </div>

  <!-- OpenCV.js (×œ×œ× API). ×× ××ª×” ×¨×•×¦×” ××•×¤×œ×™×™×Ÿ ×œ×’××¨×™: ×”×•×¨×“ ×•×©× ×” ×œ-src="./opencv.js" -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const btnPick = $("btnPick");
    const btnRun  = $("btnRun");
    const fileInp = $("file");
    const preview = $("preview");
    const outCanvas = $("out");
    const countEl = $("count");
    const statusEl = $("status");
    const hintEl = $("hint");

    const thr = $("thr"), inv = $("inv"), blur = $("blur"), morph = $("morph"), minA = $("minA"), maxA = $("maxA");
    const vThr = $("vThr"), vInv = $("vInv"), vBlur = $("vBlur"), vMorph = $("vMorph"), vMinA = $("vMinA"), vMaxA = $("vMaxA");

    let imgLoaded = false;
    let imgObj = new Image();

    function syncLabels(){
      vThr.textContent = thr.value;
      vInv.textContent = inv.value === "1" ? "×›×Ÿ" : "×œ×";
      vBlur.textContent = blur.value;
      vMorph.textContent = morph.value;
      vMinA.textContent = minA.value;
      vMaxA.textContent = maxA.value;
    }
    [thr,inv,blur,morph,minA,maxA].forEach(el => el.addEventListener("input", syncLabels));
    syncLabels();

    function setStatus(t){
      statusEl.textContent = t;
    }

    // OpenCV ready hook
    let opencvReady = false;
    function waitForCV(){
      if (typeof cv !== "undefined" && cv && cv.Mat) {
        opencvReady = true;
        setStatus("××•×›×Ÿ");
        btnPick.disabled = false;
        return;
      }
      setTimeout(waitForCV, 120);
    }
    waitForCV();

    // Fallback hint after a while
    setTimeout(() => {
      if (!opencvReady) {
        hintEl.style.display = "block";
        setStatus("OpenCV ×œ× × ×˜×¢×Ÿ");
      }
    }, 5000);

    btnPick.addEventListener("click", () => fileInp.click());

    fileInp.addEventListener("change", () => {
      const f = fileInp.files && fileInp.files[0];
      if (!f) return;

      const url = URL.createObjectURL(f);
      preview.src = url;
      imgObj = new Image();
      imgObj.onload = () => {
        imgLoaded = true;
        btnRun.disabled = !opencvReady;
        countEl.textContent = "â€”";
        // ×”×ª×××ª ×’×•×“×œ ×§× ×‘×¡
        outCanvas.width = imgObj.naturalWidth;
        outCanvas.height = imgObj.naturalHeight;
        setStatus("×ª××•× ×” × ×˜×¢× ×”");
      };
      imgObj.src = url;
    });

    btnRun.addEventListener("click", () => {
      if (!opencvReady) { setStatus("OpenCV ×œ× ××•×›×Ÿ"); return; }
      if (!imgLoaded) { setStatus("×‘×—×¨ ×ª××•× ×” ×§×•×“×"); return; }
      runCount();
    });

    function oddKernel(n){
      n = parseInt(n,10);
      if (n <= 0) return 0;
      if (n % 2 === 0) n += 1;
      return n;
    }

    function runCount(){
      setStatus("××¢×‘×“â€¦");
      const t0 = performance.now();

      // ×§×¨× ×ª××•× ×” ×œ×ª×•×š Mat
      let src = cv.imread(preview); // RGBA
      let rgba = new cv.Mat();
      src.copyTo(rgba);

      // Gray
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

      // Blur (××•×¤×¦×™×•× ×œ×™)
      const b = oddKernel(blur.value);
      if (b >= 3) {
        let ksize = new cv.Size(b, b);
        cv.GaussianBlur(gray, gray, ksize, 0, 0, cv.BORDER_DEFAULT);
      }

      // Threshold
      let bin = new cv.Mat();
      const T = parseInt(thr.value,10);
      const invert = inv.value === "1";
      cv.threshold(gray, bin, T, 255, invert ? cv.THRESH_BINARY_INV : cv.THRESH_BINARY);

      // Morph clean
      const m = parseInt(morph.value,10);
      if (m > 0) {
        const k = oddKernel(m);
        let kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(k,k));
        // OPEN ××•×¨×™×“ × ×§×•×“×•×ª ×§×˜× ×•×ª, ×•××– CLOSE ××—×‘×¨ ×—×•×¨×™× ×§×˜× ×™×
        cv.morphologyEx(bin, bin, cv.MORPH_OPEN, kernel);
        cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, kernel);
        kernel.delete();
      }

      // Contours
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      const minArea = parseInt(minA.value,10);
      const maxArea = parseInt(maxA.value,10);

      // ×¦×™×•×¨ ×ª×•×¦××•×ª + ×¡×¤×™×¨×”
      let out = rgba; // × ×¦×™×™×¨ ×¢×œ ×”×¢×ª×§ RGBA
      let count = 0;

      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);

        if (area < minArea) { cnt.delete(); continue; }
        if (maxArea > 0 && area > maxArea) { cnt.delete(); continue; }

        // ×¡×™× ×•×Ÿ × ×•×¡×£ ××•×¤×¦×™×•× ×œ×™: ××•×‘×™×™×§×˜×™× "×××•×¨×›×™× ××“×™" ×œ×¤×¢××™× ×–×” ×¨×¢×©.
        // ×¤×” × ×©××™×¨ ×¤×©×•×˜: ×¨×§ ×œ×¤×™ ×©×˜×—, ×›×™ ×–×” ×”×›×™ ×›×œ×œ×™.

        // Bounding box + draw
        const rect = cv.boundingRect(cnt);

        // ××¡×’×¨×ª
        const p1 = new cv.Point(rect.x, rect.y);
        const p2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);
        cv.rectangle(out, p1, p2, new cv.Scalar(0, 255, 0, 255), 3);

        // ××¡×¤×¨
        count++;
        cv.putText(out, String(count), new cv.Point(rect.x, Math.max(0, rect.y - 8)),
                   cv.FONT_HERSHEY_SIMPLEX, 1.1, new cv.Scalar(0,255,0,255), 3);

        cnt.delete();
      }

      cv.imshow(outCanvas, out);

      // × ×™×§×•×™
      src.delete();
      gray.delete();
      bin.delete();
      contours.delete();
      hierarchy.delete();
      // out/rgba ×›×‘×¨ reference â€“ ××‘×œ rgba ×”×•× out, × × ×§×” ×‘×¡×•×£:
      out.delete();

      countEl.textContent = String(count);

      const ms = (performance.now() - t0);
      setStatus("×¡×™×™× (" + ms.toFixed(0) + "ms)");
    }
  </script>
</body>
</html>
