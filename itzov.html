<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>×¤×Ÿ ××§×¡×¤×¨×¡ - ×”×’×¨×¡×” ×”×¡×•×¤×™×ª</title>

  <!-- GIF.js -->
  <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>

  <style>
    :root { --primary: #ff6b81; --bg: #f8f9fa; --purple: #6c5ce7; }
    body { font-family: system-ui, sans-serif; text-align: center; background-color: var(--bg); margin: 0; padding: 10px; }
    .container { max-width: 500px; margin: auto; background: white; padding: 20px; border-radius: 25px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); padding-bottom: 50px; }

    #camContainer {
      width: 100%;
      aspect-ratio: 4/5;
      max-height: 48vh;
      background: #000;
      position: relative;
      border-radius: 20px;
      overflow: hidden;
      display: none;
      margin-bottom: 10px;
    }
    #videoLive { width: 100%; height: 100%; object-fit: cover; }

    .head-guide{
      position:absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      width: 68%;
      max-width: 420px;
      aspect-ratio: 2 / 1;
      border: 6px solid yellow;
      border-bottom: none;
      border-radius: 9999px 9999px 0 0;
      box-shadow: 0 0 18px yellow;
      z-index: 10;
      pointer-events: none;
    }
    .head-guide::after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-3px;
      transform: translateX(-50%);
      width: 44px;
      height: 6px;
      background: yellow;
      border-radius: 999px;
      box-shadow: 0 0 12px yellow;
      opacity: 0.9;
    }

    .upload-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
    .box { border: 2px dashed #ddd; border-radius: 15px; height: 105px; display: flex; align-items: center; justify-content: center; position: relative; background: #fafafa; overflow: hidden; }
    img.prev { width: 100%; height: 100%; object-fit: contain; position: absolute; }

    button { background: var(--purple); color: white; border: none; padding: 15px; font-size: 18px; border-radius: 15px; cursor: pointer; width: 100%; font-weight: bold; margin-top: 10px; }
    .snap-btn { background: var(--primary); margin-top: 6px; }

    #status { font-weight: bold; color: var(--primary); margin: 12px 0; min-height: 22px; }
    video#finalVid { width: 100%; border-radius: 15px; display: none; margin-top: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); }
    .save-btn { background: #2ed573; text-decoration: none; display: none; padding: 18px; border-radius: 50px; color: white; font-weight: bold; margin-top: 15px; }

    #adjustArea { display: none; border: 2px solid var(--purple); border-radius: 15px; overflow: hidden; background: #000; margin-top: 15px; touch-action: none; }
  </style>
</head>
<body>

<div class="container">
  <h2 style="margin-bottom:5px;">âœ¨ ×¤×Ÿ ××§×¡×¤×¨×¡ âœ¨</h2>
  <p style="font-size: 12px; color: #666; margin-bottom: 12px;">×¦×™×œ×•× ×¢× ×›×•×•× ×ª ×œ×”×ª×××” ××•×©×œ××ª</p>

  <div id="camContainer">
    <video id="videoLive" autoplay playsinline muted></video>
    <div class="head-guide"></div>
  </div>

  <div id="ui-capture">
    <button id="btnOpenCam" type="button">×¤×ª×— ××¦×œ××” ×¢× ×›×•×•× ×ª ×¨××© ğŸ“¸</button>
    <button id="btnSnap" class="snap-btn" type="button" style="display:none">×œ×—×™×¦×” ×œ×¦×™×œ×•× ğŸ“¸</button>
  </div>

  <div class="upload-grid">
    <div class="box" id="boxB"><span>×œ×¤× ×™</span><img id="imgB" class="prev"></div>
    <div class="box" id="boxA"><span>××—×¨×™</span><img id="imgA" class="prev"></div>
  </div>

  <input type="file" id="fileIn" accept="image/*" capture="environment" style="display:none">

  <div id="adjustArea">
    <p style="color:white; font-size:12px; margin:5px;">×›×•×•×Ÿ ×ª××•× ×” ×¢×œ ×ª××•× ×” ğŸ‘† (×’×¨×•×¨ ×—×•×¤×©×™ ×œ×›×œ ×›×™×•×•×Ÿ)</p>
    <canvas id="adjustCanvas" style="width:100%; display:block;"></canvas>
  </div>

  <button id="btnCreate" style="display:none; background:#2ed573;" type="button">×¦×•×¨ ×¡×¨×˜×•×Ÿ ×××•×ª×’ ğŸ¬</button>

  <button id="btnGif" style="display:none; background:#ffa502;" type="button">×¦×•×¨ GIF ×××•×ª×’ ğŸï¸</button>
  <img id="finalGif" style="width:100%; border-radius:15px; display:none; margin-top:15px; box-shadow:0 5px 20px rgba(0,0,0,0.2);" alt="">
  <a id="btnDownloadGif" class="save-btn" style="display:none;">×©××™×¨×” GIF â¬‡ï¸</a>

  <div id="status"></div>
  <video id="finalVid" controls playsinline loop muted></video>
  <a id="btnDownload" class="save-btn">×©××™×¨×” ×œ×’×œ×¨×™×” â¬‡ï¸</a>
</div>

<script>
(function(){
  const video = document.getElementById('videoLive');
  const camContainer = document.getElementById('camContainer');
  const btnOpen = document.getElementById('btnOpenCam');
  const btnSnap = document.getElementById('btnSnap');
  const btnCreate = document.getElementById('btnCreate');

  const btnGif = document.getElementById('btnGif');
  const finalGif = document.getElementById('finalGif');
  const btnDownloadGif = document.getElementById('btnDownloadGif');

  const adjustArea = document.getElementById('adjustArea');
  const adjustCanvas = document.getElementById('adjustCanvas');
  const statusEl = document.getElementById('status');
  const fileIn = document.getElementById('fileIn');

  let beforeImg = new Image(), afterImg = new Image();
  let mode = 'before';
  let offsetX = 0, offsetY = 0;
  let liveStream = null;

  // âœ… Worker Blob cache (×›×“×™ ×©-GIF ×™×¢×‘×•×“ ×‘×× ×“×¨×•××™×“)
  let workerBlobUrl = null;

  function setStatus(t){ statusEl.innerText = t || ""; }

  function stopLiveCamera() {
    try {
      if (liveStream) {
        liveStream.getTracks().forEach(t => t.stop());
        liveStream = null;
      }
      video.srcObject = null;
    } catch (e) {}
  }

  function openFallbackCamera() {
    setStatus("ğŸ“· ×¤×•×ª×— ××¦×œ××” ×¨×’×™×œ×”...");
    fileIn.click();
  }

  async function openLiveCamera() {
    try {
      setStatus("×¤×•×ª×— ××¦×œ××”...");

      if (!window.isSecureContext) {
        setStatus("â„¹ï¸ × ×“×¨×© HTTPS ×œ××¦×œ××” ×—×™×”. ×¤×•×ª×— ××¦×œ××” ×¨×’×™×œ×”.");
        openFallbackCamera();
        return;
      }

      const c1 = { video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
      const c2 = { video: true, audio: false };

      stopLiveCamera();

      try {
        liveStream = await navigator.mediaDevices.getUserMedia(c1);
      } catch (e1) {
        liveStream = await navigator.mediaDevices.getUserMedia(c2);
      }

      video.srcObject = liveStream;
      await video.play();

      camContainer.style.display = 'block';
      btnSnap.style.display = 'block';
      btnOpen.style.display = 'none';
      setStatus("âœ… ××¦×œ××” ×¤×ª×•×—×”. ×œ×—×¥ ×œ×¦×™×œ×•×.");
    } catch (e) {
      setStatus("âŒ ××¦×œ××” ×—×™×” ×œ× × ×¤×ª×—×ª. ×¢×•×‘×¨ ×œ××¦×œ××” ×¨×’×™×œ×”.");
      openFallbackCamera();
    }
  }

  btnOpen.addEventListener('click', openLiveCamera);

  btnSnap.addEventListener('click', () => {
    try {
      if (!video.videoWidth || !video.videoHeight) {
        setStatus("âŒ› ×”××¦×œ××” × ×˜×¢× ×ª... × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×¨×’×¢.");
        return;
      }
      const c = document.createElement('canvas');
      c.width = video.videoWidth; c.height = video.videoHeight;
      c.getContext('2d').drawImage(video, 0, 0);
      const data = c.toDataURL('image/jpeg', 0.92);
      processPhoto(data);
    } catch (e) {
      setStatus("âŒ ×©×’×™××” ×‘×¦×™×œ×•×. × ×¡×” ×©×•×‘.");
    }
  });

  fileIn.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = (ev) => processPhoto(ev.target.result);
    reader.readAsDataURL(f);
    e.target.value = "";
  });

  function processPhoto(data) {
    if (mode === 'before') {
      beforeImg = new Image();
      beforeImg.onload = () => {
        document.getElementById('imgB').src = data;
        mode = 'after';
        setStatus("××¢×•×œ×”! ×¢×›×©×™×• ×¦×œ× ××ª ×”'××—×¨×™'");
        if (btnOpen.style.display === 'none') {
          camContainer.style.display = 'block';
          btnSnap.style.display = 'block';
        }
      };
      beforeImg.src = data;
    } else {
      afterImg = new Image();
      afterImg.onload = () => {
        document.getElementById('imgA').src = data;

        stopLiveCamera();
        camContainer.style.display = 'none';
        btnSnap.style.display = 'none';
        document.getElementById('ui-capture').style.display = 'none';

        initAdjust();
      };
      afterImg.src = data;
    }
  }

  function initAdjust() {
    adjustArea.style.display = 'block';
    btnCreate.style.display = 'block';
    btnGif.style.display = 'block';

    adjustCanvas.width = beforeImg.naturalWidth || beforeImg.width;
    adjustCanvas.height = beforeImg.naturalHeight || beforeImg.height;

    offsetX = 0; offsetY = 0;
    drawAdjust();
  }

  function drawAdjust() {
    const ctx = adjustCanvas.getContext('2d');
    const w = adjustCanvas.width, h = adjustCanvas.height;
    ctx.clearRect(0,0,w,h);

    ctx.globalAlpha = 1;
    ctx.drawImage(beforeImg, 0, 0, w, h);

    ctx.globalAlpha = 0.5;
    ctx.drawImage(afterImg, offsetX, offsetY, w, h);

    ctx.globalAlpha = 1;
    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(0, h*0.25);
    ctx.lineTo(w, h*0.25);
    ctx.stroke();
  }

  // ×’×¨×™×¨×” ×—×•×¤×©×™×ª X+Y (Pointer Events)
  let dragging = false;
  let startPX=0, startPY=0, startOX=0, startOY=0;

  adjustCanvas.addEventListener('pointerdown', (e) => {
    dragging = true;
    adjustCanvas.setPointerCapture(e.pointerId);
    startPX = e.clientX; startPY = e.clientY;
    startOX = offsetX; startOY = offsetY;
  });

  adjustCanvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;

    const dx = e.clientX - startPX;
    const dy = e.clientY - startPY;

    const rect = adjustCanvas.getBoundingClientRect();
    const scaleX = adjustCanvas.width / rect.width;
    const scaleY = adjustCanvas.height / rect.height;

    offsetX = startOX + dx * scaleX;
    offsetY = startOY + dy * scaleY;

    drawAdjust();
  });

  adjustCanvas.addEventListener('pointerup', () => dragging = false);
  adjustCanvas.addEventListener('pointercancel', () => dragging = false);

  function pickSupportedMime() {
    const candidates = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm','video/mp4'];
    for (const c of candidates) {
      if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c;
    }
    return '';
  }

  btnCreate.addEventListener('click', () => {
    setStatus("â³ ××™×™×¦×¨ ×¡×¨×˜×•×Ÿ... ×œ× ×œ×¦××ª");
    btnCreate.disabled = true;
    btnGif.disabled = true;

    const vCanvas = document.createElement('canvas');
    const vCtx = vCanvas.getContext('2d');

    const w = beforeImg.naturalWidth || beforeImg.width;
    const h = beforeImg.naturalHeight || beforeImg.height;
    vCanvas.width = w; vCanvas.height = h;

    const stream = vCanvas.captureStream(30);
    const mimeType = pickSupportedMime();

    let recorder;
    try {
      recorder = mimeType ? new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 6000000 })
                          : new MediaRecorder(stream, { videoBitsPerSecond: 6000000 });
    } catch (e) {
      setStatus("âŒ ××™×Ÿ ×ª××™×›×” ×‘×”×§×œ×˜×ª ×•×™×“××• ×‘××›×©×™×¨ ×”×–×”.");
      btnCreate.disabled = false;
      btnGif.disabled = false;
      return;
    }

    const chunks = [];
    recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
    recorder.onstop = () => {
      const finalType = (mimeType && mimeType.includes('mp4')) ? 'video/mp4' : 'video/webm';
      const blob = new Blob(chunks, { type: finalType });
      const url = URL.createObjectURL(blob);

      const finalVid = document.getElementById('finalVid');
      finalVid.src = url;
      finalVid.style.display = 'block';

      const btnDownload = document.getElementById('btnDownload');
      btnDownload.href = url;
      btnDownload.download = finalType === 'video/mp4' ? 'Express_Hair.mp4' : 'Express_Hair.webm';
      btnDownload.style.display = 'block';

      setStatus("âœ… ××•×›×Ÿ!");
      btnCreate.disabled = false;
      btnGif.disabled = false;
    };

    recorder.start();

    const start = Date.now();
    const dur = 8000;

    function render() {
      const elapsed = Date.now() - start;
      if (elapsed >= dur) { recorder.stop(); return; }

      vCtx.clearRect(0,0,w,h);

      let op = 1;
      if (elapsed < 2000) op = 1;
      else if (elapsed < 5000) op = 1 - (elapsed - 2000) / 3000;
      else op = 0;

      vCtx.globalAlpha = 1; vCtx.drawImage(afterImg, offsetX, offsetY, w, h);
      vCtx.globalAlpha = op; vCtx.drawImage(beforeImg, 0, 0, w, h);

      vCtx.globalAlpha = 1;
      const fs = w * 0.06;
      vCtx.font = `900 ${fs}px system-ui`;
      vCtx.textAlign = "center";
      const txt = "×¤×Ÿ ××§×¡×¤×¨×¡ 0507449001";

      vCtx.strokeStyle = "white";
      vCtx.lineWidth = fs * 0.2;
      vCtx.strokeText(txt, w/2, h * 0.95);

      vCtx.fillStyle = "#ff0000";
      vCtx.fillText(txt, w/2, h * 0.95);

      vCtx.fillStyle = "white";
      vCtx.shadowBlur = 10;
      vCtx.shadowColor = "black";
      vCtx.fillText(op > 0.5 ? "×œ×¤× ×™" : "××—×¨×™ âœ¨", w/2, h * 0.1);
      vCtx.shadowBlur = 0;

      requestAnimationFrame(render);
    }
    render();
  });

  // âœ… ××‘×™× worker ×¤×¢× ××—×ª ×•×™×•×¦×¨ ××× ×• Blob URL (×–×” ×”×ª×™×§×•×Ÿ ×©×¢×•×©×” ××ª GIF ×¢×•×‘×“ ×‘×× ×“×¨×•××™×“)
  async function ensureWorkerBlobUrl() {
    if (workerBlobUrl) return workerBlobUrl;

    const workerUrl = "https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js";
    const res = await fetch(workerUrl, { cache: "force-cache" });
    if (!res.ok) throw new Error("worker_fetch_failed_" + res.status);
    const code = await res.text();
    const blob = new Blob([code], { type: "application/javascript" });
    workerBlobUrl = URL.createObjectURL(blob);
    return workerBlobUrl;
  }

  // GIF (7 ×©× ×™×•×ª ×‘×œ×•×¤)
  btnGif.addEventListener('click', async () => {
    try {
      setStatus("â³ ××™×™×¦×¨ GIF... ×œ× ×œ×¦××ª");
      btnGif.disabled = true;
      btnCreate.disabled = true;

      if (typeof GIF === "undefined") {
        throw new Error("GIF_library_missing");
      }

      const w0 = beforeImg.naturalWidth || beforeImg.width;
      const h0 = beforeImg.naturalHeight || beforeImg.height;

      // GIF ×›×‘×“ ×™×•×ª×¨: ××§×˜×™×Ÿ ×¤× ×™××™×ª (×œ× ××©× ×” ×©×•× ×“×‘×¨ ×‘×“×£)
      const maxW = 720;
      const scale = Math.min(1, maxW / w0);
      const w = Math.round(w0 * scale);
      const h = Math.round(h0 * scale);

      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d');

      const fps = 12;
      const dur = 7000;
      const delay = Math.round(1000 / fps);
      const frames = Math.max(1, Math.round(dur / delay));

      const ox = offsetX * scale;
      const oy = offsetY * scale;

      const wScript = await ensureWorkerBlobUrl();

      const gif = new GIF({
        workers: 2,
        quality: 10,
        width: w,
        height: h,
        workerScript: wScript
      });

      function drawFrame(elapsed) {
        ctx.clearRect(0,0,w,h);

        let op = 1;
        if (elapsed < 2000) op = 1;
        else if (elapsed < 5000) op = 1 - (elapsed - 2000) / 3000;
        else op = 0;

        ctx.globalAlpha = 1; ctx.drawImage(afterImg, ox, oy, w, h);
        ctx.globalAlpha = op; ctx.drawImage(beforeImg, 0, 0, w, h);

        ctx.globalAlpha = 1;
        const fs = w * 0.06;
        ctx.font = `900 ${fs}px system-ui`;
        ctx.textAlign = "center";
        const txt = "×¤×Ÿ ××§×¡×¤×¨×¡ 0507449001";

        ctx.strokeStyle = "white";
        ctx.lineWidth = fs * 0.2;
        ctx.strokeText(txt, w/2, h * 0.95);

        ctx.fillStyle = "#ff0000";
        ctx.fillText(txt, w/2, h * 0.95);

        ctx.fillStyle = "white";
        ctx.shadowBlur = 10;
        ctx.shadowColor = "black";
        ctx.fillText(op > 0.5 ? "×œ×¤× ×™" : "××—×¨×™ âœ¨", w/2, h * 0.1);
        ctx.shadowBlur = 0;
      }

      for (let i = 0; i < frames; i++) {
        drawFrame(i * delay);
        gif.addFrame(ctx, { copy: true, delay });
      }

      gif.on('finished', (blob) => {
        const url = URL.createObjectURL(blob);

        finalGif.src = url;
        finalGif.style.display = 'block';

        btnDownloadGif.href = url;
        btnDownloadGif.download = "Express_Hair.gif";
        btnDownloadGif.style.display = 'block';

        setStatus("âœ… GIF ××•×›×Ÿ!");
        btnGif.disabled = false;
        btnCreate.disabled = false;
      });

      gif.render();
    } catch (e) {
      // âœ… × ×•×ª×Ÿ ×œ×š ×’× ×¡×™×‘×” ×××™×ª×™×ª ×‘××§×•× "×©×’×™××”" ×‘×œ×™ ××™×“×¢
      setStatus("âŒ ×©×’×™××” ×‘×™×¦×™×¨×ª GIF: " + (e && e.message ? e.message : "unknown") + " . × ×¡×” ×©×•×‘.");
      btnGif.disabled = false;
      btnCreate.disabled = false;
    }
  });

  window.addEventListener('pagehide', stopLiveCamera);

  setStatus("××•×›×Ÿ âœ…");
})();
</script>

</body>
</html>
